/* automatically generated by rust-bindgen 0.71.1 */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const YYJSON_MSC_VER: u32 = 0;
pub const YYJSON_IS_REAL_GCC: u32 = 0;
pub const YYJSON_CPP_VER: u32 = 0;
pub const YYJSON_HAS_CONSTANT_P: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const YYJSON_U64_TO_F64_NO_IMPL: u32 = 0;
pub const YYJSON_VERSION_MAJOR: u32 = 0;
pub const YYJSON_VERSION_MINOR: u32 = 10;
pub const YYJSON_VERSION_PATCH: u32 = 0;
pub const YYJSON_VERSION_HEX: u32 = 2560;
pub const YYJSON_VERSION_STRING: &[u8; 7] = b"0.10.0\0";
pub const YYJSON_PADDING_SIZE: u32 = 4;
pub const YYJSON_WRITE_FP_FLAG_BITS: u32 = 8;
pub const YYJSON_WRITE_FP_PREC_BITS: u32 = 4;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
unsafe extern "C" {
    #[link_name = "__bswap_16__extern"]
    pub fn __bswap_16(__bsx: __uint16_t) -> __uint16_t;
}
unsafe extern "C" {
    #[link_name = "__bswap_32__extern"]
    pub fn __bswap_32(__bsx: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    #[link_name = "__bswap_64__extern"]
    pub fn __bswap_64(__bsx: __uint64_t) -> __uint64_t;
}
unsafe extern "C" {
    #[link_name = "__uint16_identity__extern"]
    pub fn __uint16_identity(__x: __uint16_t) -> __uint16_t;
}
unsafe extern "C" {
    #[link_name = "__uint32_identity__extern"]
    pub fn __uint32_identity(__x: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    #[link_name = "__uint64_identity__extern"]
    pub fn __uint64_identity(__x: __uint64_t) -> __uint64_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq32"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq32) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start32"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start32) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
unsafe extern "C" {
    #[doc = " The version of yyjson in hex, same as `YYJSON_VERSION_HEX`."]
    pub fn yyjson_version() -> u32;
}
#[doc = " Type of a JSON value (3 bit)."]
pub type yyjson_type = u8;
#[doc = " Subtype of a JSON value (2 bit)."]
pub type yyjson_subtype = u8;
#[doc = "A memory allocator.\n\nTypically you don't need to use it, unless you want to customize your own\nmemory allocator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_alc {
    #[doc = " Same as libc's malloc(size), should not be NULL."]
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Same as libc's realloc(ptr, size), should not be NULL."]
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            old_size: usize,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Same as libc's free(ptr), should not be NULL."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, ptr: *mut ::std::os::raw::c_void),
    >,
    #[doc = " A context for malloc/realloc/free, can be NULL."]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_alc"][::std::mem::size_of::<yyjson_alc>() - 32usize];
    ["Alignment of yyjson_alc"][::std::mem::align_of::<yyjson_alc>() - 8usize];
    ["Offset of field: yyjson_alc::malloc"][::std::mem::offset_of!(yyjson_alc, malloc) - 0usize];
    ["Offset of field: yyjson_alc::realloc"][::std::mem::offset_of!(yyjson_alc, realloc) - 8usize];
    ["Offset of field: yyjson_alc::free"][::std::mem::offset_of!(yyjson_alc, free) - 16usize];
    ["Offset of field: yyjson_alc::ctx"][::std::mem::offset_of!(yyjson_alc, ctx) - 24usize];
};
unsafe extern "C" {
    #[doc = "A pool allocator uses fixed length pre-allocated memory.\n\nThis allocator may be used to avoid malloc/realloc calls. The pre-allocated\nmemory should be held by the caller. The maximum amount of memory required to\nread a JSON can be calculated using the `yyjson_read_max_memory_usage()`\nfunction, but the amount of memory required to write a JSON cannot be directly\ncalculated.\n\nThis is not a general-purpose allocator. It is designed to handle a single JSON\ndata at a time. If it is used for overly complex memory tasks, such as parsing\nmultiple JSON documents using the same allocator but releasing only a few of\nthem, it may cause memory fragmentation, resulting in performance degradation\nand memory waste.\n\n@param alc The allocator to be initialized.\nIf this parameter is NULL, the function will fail and return false.\nIf `buf` or `size` is invalid, this will be set to an empty allocator.\n@param buf The buffer memory for this allocator.\nIf this parameter is NULL, the function will fail and return false.\n@param size The size of `buf`, in bytes.\nIf this parameter is less than 8 words (32/64 bytes on 32/64-bit OS), the\nfunction will fail and return false.\n@return true if the `alc` has been successfully initialized.\n\n@par Example\n@code\n// parse JSON with stack memory\nchar buf[1024];\nyyjson_alc alc;\nyyjson_alc_pool_init(&alc, buf, 1024);\n\nconst char *json = \"{\\\"name\\\":\\\"Helvetica\\\",\\\"size\\\":16}\"\nyyjson_doc *doc = yyjson_read_opts(json, strlen(json), 0, &alc, NULL);\n// the memory of `doc` is on the stack\n@endcode\n\n@warning This Allocator is not thread-safe."]
    pub fn yyjson_alc_pool_init(
        alc: *mut yyjson_alc,
        buf: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "A dynamic allocator.\n\nThis allocator has a similar usage to the pool allocator above. However, when\nthere is not enough memory, this allocator will dynamically request more memory\nusing libc's `malloc` function, and frees it all at once when it is destroyed.\n\n@return A new dynamic allocator, or NULL if memory allocation failed.\n@note The returned value should be freed with `yyjson_alc_dyn_free()`.\n\n@warning This Allocator is not thread-safe."]
    pub fn yyjson_alc_dyn_new() -> *mut yyjson_alc;
}
unsafe extern "C" {
    #[doc = "Free a dynamic allocator which is created by `yyjson_alc_dyn_new()`.\n@param alc The dynamic allocator to be destroyed."]
    pub fn yyjson_alc_dyn_free(alc: *mut yyjson_alc);
}
unsafe extern "C" {
    #[doc = "Locate the line and column number for a byte position in a string.\nThis can be used to get better description for error position.\n\n@param str The input string.\n@param len The byte length of the input string.\n@param pos The byte position within the input string.\n@param line A pointer to receive the line number, starting from 1.\n@param col  A pointer to receive the column number, starting from 1.\n@param chr  A pointer to receive the character index, starting from 0.\n@return true on success, false if `str` is NULL or `pos` is out of bounds.\n@note Line/column/character are calculated based on Unicode characters for\ncompatibility with text editors. For multi-byte UTF-8 characters,\nthe returned value may not directly correspond to the byte position."]
    pub fn yyjson_locate_pos(
        str_: *const ::std::os::raw::c_char,
        len: usize,
        pos: usize,
        line: *mut usize,
        col: *mut usize,
        chr: *mut usize,
    ) -> bool;
}
#[doc = " Run-time options for JSON reader."]
pub type yyjson_read_flag = u32;
#[doc = " Default option (RFC 8259 compliant):\n- Read positive integer as uint64_t.\n- Read negative integer as int64_t.\n- Read floating-point number as double with round-to-nearest mode.\n- Read integer which cannot fit in uint64_t or int64_t as double.\n- Report error if double number is infinity.\n- Report error if string contains invalid UTF-8 character or BOM.\n- Report error on trailing commas, comments, inf and nan literals."]
pub const YYJSON_READ_NOFLAG: yyjson_read_flag = 0;
#[doc = " Read the input data in-situ.\nThis option allows the reader to modify and use input data to store string\nvalues, which can increase reading speed slightly.\nThe caller should hold the input data before free the document.\nThe input data must be padded by at least `YYJSON_PADDING_SIZE` bytes.\nFor example: `[1,2]` should be `[1,2]\\0\\0\\0\\0`, input length should be 5."]
pub const YYJSON_READ_INSITU: yyjson_read_flag = 1;
#[doc = " Stop when done instead of issuing an error if there's additional content\nafter a JSON document. This option may be used to parse small pieces of JSON\nin larger data, such as `NDJSON`."]
pub const YYJSON_READ_STOP_WHEN_DONE: yyjson_read_flag = 2;
#[doc = " Allow single trailing comma at the end of an object or array,\nsuch as `[1,2,3,]`, `{\"a\":1,\"b\":2,}` (non-standard)."]
pub const YYJSON_READ_ALLOW_TRAILING_COMMAS: yyjson_read_flag = 4;
#[doc = " Allow C-style single line and multiple line comments (non-standard)."]
pub const YYJSON_READ_ALLOW_COMMENTS: yyjson_read_flag = 8;
#[doc = " Allow inf/nan number and literal, case-insensitive,\nsuch as 1e999, NaN, inf, -Infinity (non-standard)."]
pub const YYJSON_READ_ALLOW_INF_AND_NAN: yyjson_read_flag = 16;
#[doc = " Read all numbers as raw strings (value with `YYJSON_TYPE_RAW` type),\ninf/nan literal is also read as raw with `ALLOW_INF_AND_NAN` flag."]
pub const YYJSON_READ_NUMBER_AS_RAW: yyjson_read_flag = 32;
#[doc = " Allow reading invalid unicode when parsing string values (non-standard).\nInvalid characters will be allowed to appear in the string values, but\ninvalid escape sequences will still be reported as errors.\nThis flag does not affect the performance of correctly encoded strings.\n\n@warning Strings in JSON values may contain incorrect encoding when this\noption is used, you need to handle these strings carefully to avoid security\nrisks."]
pub const YYJSON_READ_ALLOW_INVALID_UNICODE: yyjson_read_flag = 64;
#[doc = " Read big numbers as raw strings. These big numbers include integers that\ncannot be represented by `int64_t` and `uint64_t`, and floating-point\nnumbers that cannot be represented by finite `double`.\nThe flag will be overridden by `YYJSON_READ_NUMBER_AS_RAW` flag."]
pub const YYJSON_READ_BIGNUM_AS_RAW: yyjson_read_flag = 128;
#[doc = " Result code for JSON reader."]
pub type yyjson_read_code = u32;
#[doc = " Success, no error."]
pub const YYJSON_READ_SUCCESS: yyjson_read_code = 0;
#[doc = " Invalid parameter, such as NULL input string or 0 input length."]
pub const YYJSON_READ_ERROR_INVALID_PARAMETER: yyjson_read_code = 1;
#[doc = " Memory allocation failure occurs."]
pub const YYJSON_READ_ERROR_MEMORY_ALLOCATION: yyjson_read_code = 2;
#[doc = " Input JSON string is empty."]
pub const YYJSON_READ_ERROR_EMPTY_CONTENT: yyjson_read_code = 3;
#[doc = " Unexpected content after document, such as `[123]abc`."]
pub const YYJSON_READ_ERROR_UNEXPECTED_CONTENT: yyjson_read_code = 4;
#[doc = " Unexpected ending, such as `[123`."]
pub const YYJSON_READ_ERROR_UNEXPECTED_END: yyjson_read_code = 5;
#[doc = " Unexpected character inside the document, such as `[abc]`."]
pub const YYJSON_READ_ERROR_UNEXPECTED_CHARACTER: yyjson_read_code = 6;
#[doc = " Invalid JSON structure, such as `[1,]`."]
pub const YYJSON_READ_ERROR_JSON_STRUCTURE: yyjson_read_code = 7;
#[doc = " Invalid comment, such as unclosed multi-line comment."]
pub const YYJSON_READ_ERROR_INVALID_COMMENT: yyjson_read_code = 8;
#[doc = " Invalid number, such as `123.e12`, `000`."]
pub const YYJSON_READ_ERROR_INVALID_NUMBER: yyjson_read_code = 9;
#[doc = " Invalid string, such as invalid escaped character inside a string."]
pub const YYJSON_READ_ERROR_INVALID_STRING: yyjson_read_code = 10;
#[doc = " Invalid JSON literal, such as `truu`."]
pub const YYJSON_READ_ERROR_LITERAL: yyjson_read_code = 11;
#[doc = " Failed to open a file."]
pub const YYJSON_READ_ERROR_FILE_OPEN: yyjson_read_code = 12;
#[doc = " Failed to read a file."]
pub const YYJSON_READ_ERROR_FILE_READ: yyjson_read_code = 13;
#[doc = " Error information for JSON reader."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_read_err {
    #[doc = " Error code, see `yyjson_read_code` for all possible values."]
    pub code: yyjson_read_code,
    #[doc = " Error message, constant, no need to free (NULL if success)."]
    pub msg: *const ::std::os::raw::c_char,
    #[doc = " Error byte position for input data (0 if success)."]
    pub pos: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_read_err"][::std::mem::size_of::<yyjson_read_err>() - 24usize];
    ["Alignment of yyjson_read_err"][::std::mem::align_of::<yyjson_read_err>() - 8usize];
    ["Offset of field: yyjson_read_err::code"]
        [::std::mem::offset_of!(yyjson_read_err, code) - 0usize];
    ["Offset of field: yyjson_read_err::msg"]
        [::std::mem::offset_of!(yyjson_read_err, msg) - 8usize];
    ["Offset of field: yyjson_read_err::pos"]
        [::std::mem::offset_of!(yyjson_read_err, pos) - 16usize];
};
unsafe extern "C" {
    #[doc = "Read JSON with options.\n\nThis function is thread-safe when:\n1. The `dat` is not modified by other threads.\n2. The `alc` is thread-safe or NULL.\n\n@param dat The JSON data (UTF-8 without BOM), null-terminator is not required.\nIf this parameter is NULL, the function will fail and return NULL.\nThe `dat` will not be modified without the flag `YYJSON_READ_INSITU`, so you\ncan pass a `const char *` string and case it to `char *` if you don't use\nthe `YYJSON_READ_INSITU` flag.\n@param len The length of JSON data in bytes.\nIf this parameter is 0, the function will fail and return NULL.\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON reader.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON document, or NULL if an error occurs.\nWhen it's no longer needed, it should be freed with `yyjson_doc_free()`."]
    pub fn yyjson_read_opts(
        dat: *mut ::std::os::raw::c_char,
        len: usize,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = "Read a JSON file.\n\nThis function is thread-safe when:\n1. The file is not modified by other threads.\n2. The `alc` is thread-safe or NULL.\n\n@param path The JSON file's path.\nIf this path is NULL or invalid, the function will fail and return NULL.\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON reader.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON document, or NULL if an error occurs.\nWhen it's no longer needed, it should be freed with `yyjson_doc_free()`.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to read."]
    pub fn yyjson_read_file(
        path: *const ::std::os::raw::c_char,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = "Read JSON from a file pointer.\n\n@param fp The file pointer.\nThe data will be read from the current position of the FILE to the end.\nIf this fp is NULL or invalid, the function will fail and return NULL.\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON reader.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON document, or NULL if an error occurs.\nWhen it's no longer needed, it should be freed with `yyjson_doc_free()`.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to read."]
    pub fn yyjson_read_fp(
        fp: *mut FILE,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = "Read a JSON string.\n\nThis function is thread-safe.\n\n@param dat The JSON data (UTF-8 without BOM), null-terminator is not required.\nIf this parameter is NULL, the function will fail and return NULL.\n@param len The length of JSON data in bytes.\nIf this parameter is 0, the function will fail and return NULL.\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@return A new JSON document, or NULL if an error occurs.\nWhen it's no longer needed, it should be freed with `yyjson_doc_free()`."]
    #[link_name = "yyjson_read__extern"]
    pub fn yyjson_read(
        dat: *const ::std::os::raw::c_char,
        len: usize,
        flg: yyjson_read_flag,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = "Returns the size of maximum memory usage to read a JSON data.\n\nYou may use this value to avoid malloc() or calloc() call inside the reader\nto get better performance, or read multiple JSON with one piece of memory.\n\n@param len The length of JSON data in bytes.\n@param flg The JSON read options.\n@return The maximum memory size to read this JSON, or 0 if overflow.\n\n@par Example\n@code\n// read multiple JSON with same pre-allocated memory\n\nchar *dat1, *dat2, *dat3; // JSON data\nsize_t len1, len2, len3; // JSON length\nsize_t max_len = MAX(len1, MAX(len2, len3));\nyyjson_doc *doc;\n\n// use one allocator for multiple JSON\nsize_t size = yyjson_read_max_memory_usage(max_len, 0);\nvoid *buf = malloc(size);\nyyjson_alc alc;\nyyjson_alc_pool_init(&alc, buf, size);\n\n// no more alloc() or realloc() call during reading\ndoc = yyjson_read_opts(dat1, len1, 0, &alc, NULL);\nyyjson_doc_free(doc);\ndoc = yyjson_read_opts(dat2, len2, 0, &alc, NULL);\nyyjson_doc_free(doc);\ndoc = yyjson_read_opts(dat3, len3, 0, &alc, NULL);\nyyjson_doc_free(doc);\n\nfree(buf);\n@endcode\n@see yyjson_alc_pool_init()"]
    #[link_name = "yyjson_read_max_memory_usage__extern"]
    pub fn yyjson_read_max_memory_usage(len: usize, flg: yyjson_read_flag) -> usize;
}
unsafe extern "C" {
    #[doc = "Read a JSON number.\n\nThis function is thread-safe when data is not modified by other threads.\n\n@param dat The JSON data (UTF-8 without BOM), null-terminator is required.\nIf this parameter is NULL, the function will fail and return NULL.\n@param val The output value where result is stored.\nIf this parameter is NULL, the function will fail and return NULL.\nThe value will hold either UINT or SINT or REAL number;\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\nSupports `YYJSON_READ_NUMBER_AS_RAW` and `YYJSON_READ_ALLOW_INF_AND_NAN`.\n@param alc The memory allocator used for long number.\nIt is only used when the built-in floating point reader is disabled.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return If successful, a pointer to the character after the last character\nused in the conversion, NULL if an error occurs."]
    pub fn yyjson_read_number(
        dat: *const ::std::os::raw::c_char,
        val: *mut yyjson_val,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Read a JSON number.\n\nThis function is thread-safe when data is not modified by other threads.\n\n@param dat The JSON data (UTF-8 without BOM), null-terminator is required.\nIf this parameter is NULL, the function will fail and return NULL.\n@param val The output value where result is stored.\nIf this parameter is NULL, the function will fail and return NULL.\nThe value will hold either UINT or SINT or REAL number;\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\nSupports `YYJSON_READ_NUMBER_AS_RAW` and `YYJSON_READ_ALLOW_INF_AND_NAN`.\n@param alc The memory allocator used for long number.\nIt is only used when the built-in floating point reader is disabled.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return If successful, a pointer to the character after the last character\nused in the conversion, NULL if an error occurs."]
    #[link_name = "yyjson_mut_read_number__extern"]
    pub fn yyjson_mut_read_number(
        dat: *const ::std::os::raw::c_char,
        val: *mut yyjson_mut_val,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " Run-time options for JSON writer."]
pub type yyjson_write_flag = u32;
#[doc = " Default option:\n- Write JSON minify.\n- Report error on inf or nan number.\n- Report error on invalid UTF-8 string.\n- Do not escape unicode or slash."]
pub const YYJSON_WRITE_NOFLAG: yyjson_write_flag = 0;
#[doc = " Write JSON pretty with 4 space indent."]
pub const YYJSON_WRITE_PRETTY: yyjson_write_flag = 1;
#[doc = " Escape unicode as `uXXXX`, make the output ASCII only."]
pub const YYJSON_WRITE_ESCAPE_UNICODE: yyjson_write_flag = 2;
#[doc = " Escape '/' as '\\/'."]
pub const YYJSON_WRITE_ESCAPE_SLASHES: yyjson_write_flag = 4;
#[doc = " Write inf and nan number as 'Infinity' and 'NaN' literal (non-standard)."]
pub const YYJSON_WRITE_ALLOW_INF_AND_NAN: yyjson_write_flag = 8;
#[doc = " Write inf and nan number as null literal.\nThis flag will override `YYJSON_WRITE_ALLOW_INF_AND_NAN` flag."]
pub const YYJSON_WRITE_INF_AND_NAN_AS_NULL: yyjson_write_flag = 16;
#[doc = " Allow invalid unicode when encoding string values (non-standard).\nInvalid characters in string value will be copied byte by byte.\nIf `YYJSON_WRITE_ESCAPE_UNICODE` flag is also set, invalid character will be\nescaped as `U+FFFD` (replacement character).\nThis flag does not affect the performance of correctly encoded strings."]
pub const YYJSON_WRITE_ALLOW_INVALID_UNICODE: yyjson_write_flag = 32;
#[doc = " Write JSON pretty with 2 space indent.\nThis flag will override `YYJSON_WRITE_PRETTY` flag."]
pub const YYJSON_WRITE_PRETTY_TWO_SPACES: yyjson_write_flag = 64;
#[doc = " Adds a newline character `\\n` at the end of the JSON.\nThis can be helpful for text editors or NDJSON."]
pub const YYJSON_WRITE_NEWLINE_AT_END: yyjson_write_flag = 128;
#[doc = " Result code for JSON writer"]
pub type yyjson_write_code = u32;
#[doc = " Success, no error."]
pub const YYJSON_WRITE_SUCCESS: yyjson_write_code = 0;
#[doc = " Invalid parameter, such as NULL document."]
pub const YYJSON_WRITE_ERROR_INVALID_PARAMETER: yyjson_write_code = 1;
#[doc = " Memory allocation failure occurs."]
pub const YYJSON_WRITE_ERROR_MEMORY_ALLOCATION: yyjson_write_code = 2;
#[doc = " Invalid value type in JSON document."]
pub const YYJSON_WRITE_ERROR_INVALID_VALUE_TYPE: yyjson_write_code = 3;
#[doc = " NaN or Infinity number occurs."]
pub const YYJSON_WRITE_ERROR_NAN_OR_INF: yyjson_write_code = 4;
#[doc = " Failed to open a file."]
pub const YYJSON_WRITE_ERROR_FILE_OPEN: yyjson_write_code = 5;
#[doc = " Failed to write a file."]
pub const YYJSON_WRITE_ERROR_FILE_WRITE: yyjson_write_code = 6;
#[doc = " Invalid unicode in string."]
pub const YYJSON_WRITE_ERROR_INVALID_STRING: yyjson_write_code = 7;
#[doc = " Error information for JSON writer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_write_err {
    #[doc = " Error code, see `yyjson_write_code` for all possible values."]
    pub code: yyjson_write_code,
    #[doc = " Error message, constant, no need to free (NULL if success)."]
    pub msg: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_write_err"][::std::mem::size_of::<yyjson_write_err>() - 16usize];
    ["Alignment of yyjson_write_err"][::std::mem::align_of::<yyjson_write_err>() - 8usize];
    ["Offset of field: yyjson_write_err::code"]
        [::std::mem::offset_of!(yyjson_write_err, code) - 0usize];
    ["Offset of field: yyjson_write_err::msg"]
        [::std::mem::offset_of!(yyjson_write_err, msg) - 8usize];
};
unsafe extern "C" {
    #[doc = " Returns the root value of this JSON document.\nReturns NULL if `doc` is NULL."]
    #[link_name = "yyjson_doc_get_root__extern"]
    pub fn yyjson_doc_get_root(doc: *mut yyjson_doc) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = " Returns read size of input JSON data.\nReturns 0 if `doc` is NULL.\nFor example: the read size of `[1,2,3]` is 7 bytes."]
    #[link_name = "yyjson_doc_get_read_size__extern"]
    pub fn yyjson_doc_get_read_size(doc: *mut yyjson_doc) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns total value count in this JSON document.\nReturns 0 if `doc` is NULL.\nFor example: the value count of `[1,2,3]` is 4."]
    #[link_name = "yyjson_doc_get_val_count__extern"]
    pub fn yyjson_doc_get_val_count(doc: *mut yyjson_doc) -> usize;
}
unsafe extern "C" {
    #[doc = " Release the JSON document and free the memory.\nAfter calling this function, the `doc` and all values from the `doc` are no\nlonger available. This function will do nothing if the `doc` is NULL."]
    #[link_name = "yyjson_doc_free__extern"]
    pub fn yyjson_doc_free(doc: *mut yyjson_doc);
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is raw.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_raw__extern"]
    pub fn yyjson_is_raw(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is `null`.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_null__extern"]
    pub fn yyjson_is_null(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is `true`.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_true__extern"]
    pub fn yyjson_is_true(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is `false`.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_false__extern"]
    pub fn yyjson_is_false(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is bool (true/false).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_bool__extern"]
    pub fn yyjson_is_bool(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is unsigned integer (uint64_t).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_uint__extern"]
    pub fn yyjson_is_uint(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is signed integer (int64_t).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_sint__extern"]
    pub fn yyjson_is_sint(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is integer (uint64_t/int64_t).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_int__extern"]
    pub fn yyjson_is_int(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is real number (double).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_real__extern"]
    pub fn yyjson_is_real(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is number (uint64_t/int64_t/double).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_num__extern"]
    pub fn yyjson_is_num(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is string.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_str__extern"]
    pub fn yyjson_is_str(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is array.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_arr__extern"]
    pub fn yyjson_is_arr(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is object.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_obj__extern"]
    pub fn yyjson_is_obj(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is container (array/object).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_is_ctn__extern"]
    pub fn yyjson_is_ctn(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the JSON value's type.\nReturns YYJSON_TYPE_NONE if `val` is NULL."]
    #[link_name = "yyjson_get_type__extern"]
    pub fn yyjson_get_type(val: *mut yyjson_val) -> yyjson_type;
}
unsafe extern "C" {
    #[doc = " Returns the JSON value's subtype.\nReturns YYJSON_SUBTYPE_NONE if `val` is NULL."]
    #[link_name = "yyjson_get_subtype__extern"]
    pub fn yyjson_get_subtype(val: *mut yyjson_val) -> yyjson_subtype;
}
unsafe extern "C" {
    #[doc = " Returns the JSON value's tag.\nReturns 0 if `val` is NULL."]
    #[link_name = "yyjson_get_tag__extern"]
    pub fn yyjson_get_tag(val: *mut yyjson_val) -> u8;
}
unsafe extern "C" {
    #[doc = " Returns the JSON value's type description.\nThe return value should be one of these strings: \"raw\", \"null\", \"string\",\n\"array\", \"object\", \"true\", \"false\", \"uint\", \"sint\", \"real\", \"unknown\"."]
    #[link_name = "yyjson_get_type_desc__extern"]
    pub fn yyjson_get_type_desc(val: *mut yyjson_val) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the content if the value is raw.\nReturns NULL if `val` is NULL or type is not raw."]
    #[link_name = "yyjson_get_raw__extern"]
    pub fn yyjson_get_raw(val: *mut yyjson_val) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the content if the value is bool.\nReturns NULL if `val` is NULL or type is not bool."]
    #[link_name = "yyjson_get_bool__extern"]
    pub fn yyjson_get_bool(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the content and cast to uint64_t.\nReturns 0 if `val` is NULL or type is not integer(sint/uint)."]
    #[link_name = "yyjson_get_uint__extern"]
    pub fn yyjson_get_uint(val: *mut yyjson_val) -> u64;
}
unsafe extern "C" {
    #[doc = " Returns the content and cast to int64_t.\nReturns 0 if `val` is NULL or type is not integer(sint/uint)."]
    #[link_name = "yyjson_get_sint__extern"]
    pub fn yyjson_get_sint(val: *mut yyjson_val) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the content and cast to int.\nReturns 0 if `val` is NULL or type is not integer(sint/uint)."]
    #[link_name = "yyjson_get_int__extern"]
    pub fn yyjson_get_int(val: *mut yyjson_val) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the content if the value is real number, or 0.0 on error.\nReturns 0.0 if `val` is NULL or type is not real(double)."]
    #[link_name = "yyjson_get_real__extern"]
    pub fn yyjson_get_real(val: *mut yyjson_val) -> f64;
}
unsafe extern "C" {
    #[doc = " Returns the content and typecast to `double` if the value is number.\nReturns 0.0 if `val` is NULL or type is not number(uint/sint/real)."]
    #[link_name = "yyjson_get_num__extern"]
    pub fn yyjson_get_num(val: *mut yyjson_val) -> f64;
}
unsafe extern "C" {
    #[doc = " Returns the content if the value is string.\nReturns NULL if `val` is NULL or type is not string."]
    #[link_name = "yyjson_get_str__extern"]
    pub fn yyjson_get_str(val: *mut yyjson_val) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the content length (string length, array size, object size.\nReturns 0 if `val` is NULL or type is not string/array/object."]
    #[link_name = "yyjson_get_len__extern"]
    pub fn yyjson_get_len(val: *mut yyjson_val) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is equals to a string.\nReturns false if input is NULL or type is not string."]
    #[link_name = "yyjson_equals_str__extern"]
    pub fn yyjson_equals_str(val: *mut yyjson_val, str_: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is equals to a string.\nThe `str` should be a UTF-8 string, null-terminator is not required.\nReturns false if input is NULL or type is not string."]
    #[link_name = "yyjson_equals_strn__extern"]
    pub fn yyjson_equals_strn(
        val: *mut yyjson_val,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether two JSON values are equal (deep compare).\nReturns false if input is NULL.\n@note the result may be inaccurate if object has duplicate keys.\n@warning This function is recursive and may cause a stack overflow\nif the object level is too deep."]
    #[link_name = "yyjson_equals__extern"]
    pub fn yyjson_equals(lhs: *mut yyjson_val, rhs: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to raw.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_raw__extern"]
    pub fn yyjson_set_raw(
        val: *mut yyjson_val,
        raw: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to null.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_null__extern"]
    pub fn yyjson_set_null(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to bool.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_bool__extern"]
    pub fn yyjson_set_bool(val: *mut yyjson_val, num: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to uint.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_uint__extern"]
    pub fn yyjson_set_uint(val: *mut yyjson_val, num: u64) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to sint.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_sint__extern"]
    pub fn yyjson_set_sint(val: *mut yyjson_val, num: i64) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to int.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_int__extern"]
    pub fn yyjson_set_int(val: *mut yyjson_val, num: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to float.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_float__extern"]
    pub fn yyjson_set_float(val: *mut yyjson_val, num: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to double.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_double__extern"]
    pub fn yyjson_set_double(val: *mut yyjson_val, num: f64) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to real.\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_real__extern"]
    pub fn yyjson_set_real(val: *mut yyjson_val, num: f64) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the floating-point number's output format to fixed-point notation.\nReturns false if input is NULL or `val` is not real type.\n@see YYJSON_WRITE_FP_TO_FIXED flag.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_fp_to_fixed__extern"]
    pub fn yyjson_set_fp_to_fixed(val: *mut yyjson_val, prec: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the floating-point number's output format to single-precision.\nReturns false if input is NULL or `val` is not real type.\n@see YYJSON_WRITE_FP_TO_FLOAT flag.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_fp_to_float__extern"]
    pub fn yyjson_set_fp_to_float(val: *mut yyjson_val, flt: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to string (null-terminated).\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_str__extern"]
    pub fn yyjson_set_str(val: *mut yyjson_val, str_: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to string (with length).\nReturns false if input is NULL or `val` is object or array.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_strn__extern"]
    pub fn yyjson_set_strn(
        val: *mut yyjson_val,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Marks this string as not needing to be escaped during JSON writing.\nThis can be used to avoid the overhead of escaping if the string contains\nonly characters that do not require escaping.\nReturns false if input is NULL or `val` is not string.\n@see YYJSON_SUBTYPE_NOESC subtype.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_set_str_noesc__extern"]
    pub fn yyjson_set_str_noesc(val: *mut yyjson_val, noesc: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the number of elements in this array.\nReturns 0 if `arr` is NULL or type is not array."]
    #[link_name = "yyjson_arr_size__extern"]
    pub fn yyjson_arr_size(arr: *mut yyjson_val) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the element at the specified position in this array.\nReturns NULL if array is NULL/empty or the index is out of bounds.\n@warning This function takes a linear search time if array is not flat.\nFor example: `[1,{},3]` is flat, `[1,[2],3]` is not flat."]
    #[link_name = "yyjson_arr_get__extern"]
    pub fn yyjson_arr_get(arr: *mut yyjson_val, idx: usize) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = " Returns the first element of this array.\nReturns NULL if `arr` is NULL/empty or type is not array."]
    #[link_name = "yyjson_arr_get_first__extern"]
    pub fn yyjson_arr_get_first(arr: *mut yyjson_val) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = " Returns the last element of this array.\nReturns NULL if `arr` is NULL/empty or type is not array.\n@warning This function takes a linear search time if array is not flat.\nFor example: `[1,{},3]` is flat, `[1,[2],3]` is not flat."]
    #[link_name = "yyjson_arr_get_last__extern"]
    pub fn yyjson_arr_get_last(arr: *mut yyjson_val) -> *mut yyjson_val;
}
#[doc = "A JSON array iterator.\n\n@par Example\n@code\nyyjson_val *val;\nyyjson_arr_iter iter = yyjson_arr_iter_with(arr);\nwhile ((val = yyjson_arr_iter_next(&iter))) {\nyour_func(val);\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_arr_iter {
    #[doc = "< next value's index"]
    pub idx: usize,
    #[doc = "< maximum index (arr.size)"]
    pub max: usize,
    #[doc = "< next value"]
    pub cur: *mut yyjson_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_arr_iter"][::std::mem::size_of::<yyjson_arr_iter>() - 24usize];
    ["Alignment of yyjson_arr_iter"][::std::mem::align_of::<yyjson_arr_iter>() - 8usize];
    ["Offset of field: yyjson_arr_iter::idx"]
        [::std::mem::offset_of!(yyjson_arr_iter, idx) - 0usize];
    ["Offset of field: yyjson_arr_iter::max"]
        [::std::mem::offset_of!(yyjson_arr_iter, max) - 8usize];
    ["Offset of field: yyjson_arr_iter::cur"]
        [::std::mem::offset_of!(yyjson_arr_iter, cur) - 16usize];
};
unsafe extern "C" {
    #[doc = "Initialize an iterator for this array.\n\n@param arr The array to be iterated over.\nIf this parameter is NULL or not an array, `iter` will be set to empty.\n@param iter The iterator to be initialized.\nIf this parameter is NULL, the function will fail and return false.\n@return true if the `iter` has been successfully initialized.\n\n@note The iterator does not need to be destroyed."]
    #[link_name = "yyjson_arr_iter_init__extern"]
    pub fn yyjson_arr_iter_init(arr: *mut yyjson_val, iter: *mut yyjson_arr_iter) -> bool;
}
unsafe extern "C" {
    #[doc = "Create an iterator with an array , same as `yyjson_arr_iter_init()`.\n\n@param arr The array to be iterated over.\nIf this parameter is NULL or not an array, an empty iterator will returned.\n@return A new iterator for the array.\n\n@note The iterator does not need to be destroyed."]
    #[link_name = "yyjson_arr_iter_with__extern"]
    pub fn yyjson_arr_iter_with(arr: *mut yyjson_val) -> yyjson_arr_iter;
}
unsafe extern "C" {
    #[doc = "Returns whether the iteration has more elements.\nIf `iter` is NULL, this function will return false."]
    #[link_name = "yyjson_arr_iter_has_next__extern"]
    pub fn yyjson_arr_iter_has_next(iter: *mut yyjson_arr_iter) -> bool;
}
unsafe extern "C" {
    #[doc = "Returns the next element in the iteration, or NULL on end.\nIf `iter` is NULL, this function will return NULL."]
    #[link_name = "yyjson_arr_iter_next__extern"]
    pub fn yyjson_arr_iter_next(iter: *mut yyjson_arr_iter) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = " Returns the number of key-value pairs in this object.\nReturns 0 if `obj` is NULL or type is not object."]
    #[link_name = "yyjson_obj_size__extern"]
    pub fn yyjson_obj_size(obj: *mut yyjson_val) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the value to which the specified key is mapped.\nReturns NULL if this object contains no mapping for the key.\nReturns NULL if `obj/key` is NULL, or type is not object.\n\nThe `key` should be a null-terminated UTF-8 string.\n\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_obj_get__extern"]
    pub fn yyjson_obj_get(
        obj: *mut yyjson_val,
        key: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = " Returns the value to which the specified key is mapped.\nReturns NULL if this object contains no mapping for the key.\nReturns NULL if `obj/key` is NULL, or type is not object.\n\nThe `key` should be a UTF-8 string, null-terminator is not required.\nThe `key_len` should be the length of the key, in bytes.\n\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_obj_getn__extern"]
    pub fn yyjson_obj_getn(
        obj: *mut yyjson_val,
        key: *const ::std::os::raw::c_char,
        key_len: usize,
    ) -> *mut yyjson_val;
}
#[doc = "A JSON object iterator.\n\n@par Example\n@code\nyyjson_val *key, *val;\nyyjson_obj_iter iter = yyjson_obj_iter_with(obj);\nwhile ((key = yyjson_obj_iter_next(&iter))) {\nval = yyjson_obj_iter_get_val(key);\nyour_func(key, val);\n}\n@endcode\n\nIf the ordering of the keys is known at compile-time, you can use this method\nto speed up value lookups:\n@code\n// {\"k1\":1, \"k2\": 3, \"k3\": 3}\nyyjson_val *key, *val;\nyyjson_obj_iter iter = yyjson_obj_iter_with(obj);\nyyjson_val *v1 = yyjson_obj_iter_get(&iter, \"k1\");\nyyjson_val *v3 = yyjson_obj_iter_get(&iter, \"k3\");\n@endcode\n@see yyjson_obj_iter_get() and yyjson_obj_iter_getn()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_obj_iter {
    #[doc = "< next key's index"]
    pub idx: usize,
    #[doc = "< maximum key index (obj.size)"]
    pub max: usize,
    #[doc = "< next key"]
    pub cur: *mut yyjson_val,
    #[doc = "< the object being iterated"]
    pub obj: *mut yyjson_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_obj_iter"][::std::mem::size_of::<yyjson_obj_iter>() - 32usize];
    ["Alignment of yyjson_obj_iter"][::std::mem::align_of::<yyjson_obj_iter>() - 8usize];
    ["Offset of field: yyjson_obj_iter::idx"]
        [::std::mem::offset_of!(yyjson_obj_iter, idx) - 0usize];
    ["Offset of field: yyjson_obj_iter::max"]
        [::std::mem::offset_of!(yyjson_obj_iter, max) - 8usize];
    ["Offset of field: yyjson_obj_iter::cur"]
        [::std::mem::offset_of!(yyjson_obj_iter, cur) - 16usize];
    ["Offset of field: yyjson_obj_iter::obj"]
        [::std::mem::offset_of!(yyjson_obj_iter, obj) - 24usize];
};
unsafe extern "C" {
    #[doc = "Initialize an iterator for this object.\n\n@param obj The object to be iterated over.\nIf this parameter is NULL or not an object, `iter` will be set to empty.\n@param iter The iterator to be initialized.\nIf this parameter is NULL, the function will fail and return false.\n@return true if the `iter` has been successfully initialized.\n\n@note The iterator does not need to be destroyed."]
    #[link_name = "yyjson_obj_iter_init__extern"]
    pub fn yyjson_obj_iter_init(obj: *mut yyjson_val, iter: *mut yyjson_obj_iter) -> bool;
}
unsafe extern "C" {
    #[doc = "Create an iterator with an object, same as `yyjson_obj_iter_init()`.\n\n@param obj The object to be iterated over.\nIf this parameter is NULL or not an object, an empty iterator will returned.\n@return A new iterator for the object.\n\n@note The iterator does not need to be destroyed."]
    #[link_name = "yyjson_obj_iter_with__extern"]
    pub fn yyjson_obj_iter_with(obj: *mut yyjson_val) -> yyjson_obj_iter;
}
unsafe extern "C" {
    #[doc = "Returns whether the iteration has more elements.\nIf `iter` is NULL, this function will return false."]
    #[link_name = "yyjson_obj_iter_has_next__extern"]
    pub fn yyjson_obj_iter_has_next(iter: *mut yyjson_obj_iter) -> bool;
}
unsafe extern "C" {
    #[doc = "Returns the next key in the iteration, or NULL on end.\nIf `iter` is NULL, this function will return NULL."]
    #[link_name = "yyjson_obj_iter_next__extern"]
    pub fn yyjson_obj_iter_next(iter: *mut yyjson_obj_iter) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = "Returns the value for key inside the iteration.\nIf `iter` is NULL, this function will return NULL."]
    #[link_name = "yyjson_obj_iter_get_val__extern"]
    pub fn yyjson_obj_iter_get_val(key: *mut yyjson_val) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = "Iterates to a specified key and returns the value.\n\nThis function does the same thing as `yyjson_obj_get()`, but is much faster\nif the ordering of the keys is known at compile-time and you are using the same\norder to look up the values. If the key exists in this object, then the\niterator will stop at the next key, otherwise the iterator will not change and\nNULL is returned.\n\n@param iter The object iterator, should not be NULL.\n@param key The key, should be a UTF-8 string with null-terminator.\n@return The value to which the specified key is mapped.\nNULL if this object contains no mapping for the key or input is invalid.\n\n@warning This function takes a linear search time if the key is not nearby."]
    #[link_name = "yyjson_obj_iter_get__extern"]
    pub fn yyjson_obj_iter_get(
        iter: *mut yyjson_obj_iter,
        key: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = "Iterates to a specified key and returns the value.\n\nThis function does the same thing as `yyjson_obj_getn()`, but is much faster\nif the ordering of the keys is known at compile-time and you are using the same\norder to look up the values. If the key exists in this object, then the\niterator will stop at the next key, otherwise the iterator will not change and\nNULL is returned.\n\n@param iter The object iterator, should not be NULL.\n@param key The key, should be a UTF-8 string, null-terminator is not required.\n@param key_len The the length of `key`, in bytes.\n@return The value to which the specified key is mapped.\nNULL if this object contains no mapping for the key or input is invalid.\n\n@warning This function takes a linear search time if the key is not nearby."]
    #[link_name = "yyjson_obj_iter_getn__extern"]
    pub fn yyjson_obj_iter_getn(
        iter: *mut yyjson_obj_iter,
        key: *const ::std::os::raw::c_char,
        key_len: usize,
    ) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[doc = " Returns the root value of this JSON document.\nReturns NULL if `doc` is NULL."]
    #[link_name = "yyjson_mut_doc_get_root__extern"]
    pub fn yyjson_mut_doc_get_root(doc: *mut yyjson_mut_doc) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Sets the root value of this JSON document.\nPass NULL to clear root value of the document."]
    #[link_name = "yyjson_mut_doc_set_root__extern"]
    pub fn yyjson_mut_doc_set_root(doc: *mut yyjson_mut_doc, root: *mut yyjson_mut_val);
}
unsafe extern "C" {
    #[doc = "Set the string pool size for a mutable document.\nThis function does not allocate memory immediately, but uses the size when\nthe next memory allocation is needed.\n\nIf the caller knows the approximate bytes of strings that the document needs to\nstore (e.g. copy string with `yyjson_mut_strcpy` function), setting a larger\nsize can avoid multiple memory allocations and improve performance.\n\n@param doc The mutable document.\n@param len The desired string pool size in bytes (total string length).\n@return true if successful, false if size is 0 or overflow."]
    pub fn yyjson_mut_doc_set_str_pool_size(doc: *mut yyjson_mut_doc, len: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the value pool size for a mutable document.\nThis function does not allocate memory immediately, but uses the size when\nthe next memory allocation is needed.\n\nIf the caller knows the approximate number of values that the document needs to\nstore (e.g. create new value with `yyjson_mut_xxx` functions), setting a larger\nsize can avoid multiple memory allocations and improve performance.\n\n@param doc The mutable document.\n@param count The desired value pool size (number of `yyjson_mut_val`).\n@return true if successful, false if size is 0 or overflow."]
    pub fn yyjson_mut_doc_set_val_pool_size(doc: *mut yyjson_mut_doc, count: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Release the JSON document and free the memory.\nAfter calling this function, the `doc` and all values from the `doc` are no\nlonger available. This function will do nothing if the `doc` is NULL."]
    pub fn yyjson_mut_doc_free(doc: *mut yyjson_mut_doc);
}
unsafe extern "C" {
    #[doc = " Creates and returns a new mutable JSON document, returns NULL on error.\nIf allocator is NULL, the default allocator will be used."]
    pub fn yyjson_mut_doc_new(alc: *const yyjson_alc) -> *mut yyjson_mut_doc;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new mutable document from input, returns NULL on error.\nThis makes a `deep-copy` on the immutable document.\nIf allocator is NULL, the default allocator will be used.\n@note `imut_doc` -> `mut_doc`."]
    pub fn yyjson_doc_mut_copy(doc: *mut yyjson_doc, alc: *const yyjson_alc)
        -> *mut yyjson_mut_doc;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new mutable document from input, returns NULL on error.\nThis makes a `deep-copy` on the mutable document.\nIf allocator is NULL, the default allocator will be used.\n@note `mut_doc` -> `mut_doc`."]
    pub fn yyjson_mut_doc_mut_copy(
        doc: *mut yyjson_mut_doc,
        alc: *const yyjson_alc,
    ) -> *mut yyjson_mut_doc;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new mutable value from input, returns NULL on error.\nThis makes a `deep-copy` on the immutable value.\nThe memory was managed by mutable document.\n@note `imut_val` -> `mut_val`."]
    pub fn yyjson_val_mut_copy(
        doc: *mut yyjson_mut_doc,
        val: *mut yyjson_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new mutable value from input, returns NULL on error.\nThis makes a `deep-copy` on the mutable value.\nThe memory was managed by mutable document.\n@note `mut_val` -> `mut_val`.\n@warning This function is recursive and may cause a stack overflow\nif the object level is too deep."]
    pub fn yyjson_mut_val_mut_copy(
        doc: *mut yyjson_mut_doc,
        val: *mut yyjson_mut_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new immutable document from input,\nreturns NULL on error. This makes a `deep-copy` on the mutable document.\nThe returned document should be freed with `yyjson_doc_free()`.\n@note `mut_doc` -> `imut_doc`.\n@warning This function is recursive and may cause a stack overflow\nif the object level is too deep."]
    pub fn yyjson_mut_doc_imut_copy(
        doc: *mut yyjson_mut_doc,
        alc: *const yyjson_alc,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new immutable document from input,\nreturns NULL on error. This makes a `deep-copy` on the mutable value.\nThe returned document should be freed with `yyjson_doc_free()`.\n@note `mut_val` -> `imut_doc`.\n@warning This function is recursive and may cause a stack overflow\nif the object level is too deep."]
    pub fn yyjson_mut_val_imut_copy(
        val: *mut yyjson_mut_val,
        alc: *const yyjson_alc,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is raw.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_raw__extern"]
    pub fn yyjson_mut_is_raw(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is `null`.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_null__extern"]
    pub fn yyjson_mut_is_null(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is `true`.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_true__extern"]
    pub fn yyjson_mut_is_true(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is `false`.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_false__extern"]
    pub fn yyjson_mut_is_false(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is bool (true/false).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_bool__extern"]
    pub fn yyjson_mut_is_bool(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is unsigned integer (uint64_t).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_uint__extern"]
    pub fn yyjson_mut_is_uint(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is signed integer (int64_t).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_sint__extern"]
    pub fn yyjson_mut_is_sint(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is integer (uint64_t/int64_t).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_int__extern"]
    pub fn yyjson_mut_is_int(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is real number (double).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_real__extern"]
    pub fn yyjson_mut_is_real(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is number (uint/sint/real).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_num__extern"]
    pub fn yyjson_mut_is_num(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is string.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_str__extern"]
    pub fn yyjson_mut_is_str(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is array.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_arr__extern"]
    pub fn yyjson_mut_is_arr(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is object.\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_obj__extern"]
    pub fn yyjson_mut_is_obj(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is container (array/object).\nReturns false if `val` is NULL."]
    #[link_name = "yyjson_mut_is_ctn__extern"]
    pub fn yyjson_mut_is_ctn(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the JSON value's type.\nReturns `YYJSON_TYPE_NONE` if `val` is NULL."]
    #[link_name = "yyjson_mut_get_type__extern"]
    pub fn yyjson_mut_get_type(val: *mut yyjson_mut_val) -> yyjson_type;
}
unsafe extern "C" {
    #[doc = " Returns the JSON value's subtype.\nReturns `YYJSON_SUBTYPE_NONE` if `val` is NULL."]
    #[link_name = "yyjson_mut_get_subtype__extern"]
    pub fn yyjson_mut_get_subtype(val: *mut yyjson_mut_val) -> yyjson_subtype;
}
unsafe extern "C" {
    #[doc = " Returns the JSON value's tag.\nReturns 0 if `val` is NULL."]
    #[link_name = "yyjson_mut_get_tag__extern"]
    pub fn yyjson_mut_get_tag(val: *mut yyjson_mut_val) -> u8;
}
unsafe extern "C" {
    #[doc = " Returns the JSON value's type description.\nThe return value should be one of these strings: \"raw\", \"null\", \"string\",\n\"array\", \"object\", \"true\", \"false\", \"uint\", \"sint\", \"real\", \"unknown\"."]
    #[link_name = "yyjson_mut_get_type_desc__extern"]
    pub fn yyjson_mut_get_type_desc(val: *mut yyjson_mut_val) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the content if the value is raw.\nReturns NULL if `val` is NULL or type is not raw."]
    #[link_name = "yyjson_mut_get_raw__extern"]
    pub fn yyjson_mut_get_raw(val: *mut yyjson_mut_val) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the content if the value is bool.\nReturns NULL if `val` is NULL or type is not bool."]
    #[link_name = "yyjson_mut_get_bool__extern"]
    pub fn yyjson_mut_get_bool(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the content and cast to uint64_t.\nReturns 0 if `val` is NULL or type is not integer(sint/uint)."]
    #[link_name = "yyjson_mut_get_uint__extern"]
    pub fn yyjson_mut_get_uint(val: *mut yyjson_mut_val) -> u64;
}
unsafe extern "C" {
    #[doc = " Returns the content and cast to int64_t.\nReturns 0 if `val` is NULL or type is not integer(sint/uint)."]
    #[link_name = "yyjson_mut_get_sint__extern"]
    pub fn yyjson_mut_get_sint(val: *mut yyjson_mut_val) -> i64;
}
unsafe extern "C" {
    #[doc = " Returns the content and cast to int.\nReturns 0 if `val` is NULL or type is not integer(sint/uint)."]
    #[link_name = "yyjson_mut_get_int__extern"]
    pub fn yyjson_mut_get_int(val: *mut yyjson_mut_val) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the content if the value is real number.\nReturns 0.0 if `val` is NULL or type is not real(double)."]
    #[link_name = "yyjson_mut_get_real__extern"]
    pub fn yyjson_mut_get_real(val: *mut yyjson_mut_val) -> f64;
}
unsafe extern "C" {
    #[doc = " Returns the content and typecast to `double` if the value is number.\nReturns 0.0 if `val` is NULL or type is not number(uint/sint/real)."]
    #[link_name = "yyjson_mut_get_num__extern"]
    pub fn yyjson_mut_get_num(val: *mut yyjson_mut_val) -> f64;
}
unsafe extern "C" {
    #[doc = " Returns the content if the value is string.\nReturns NULL if `val` is NULL or type is not string."]
    #[link_name = "yyjson_mut_get_str__extern"]
    pub fn yyjson_mut_get_str(val: *mut yyjson_mut_val) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the content length (string length, array size, object size.\nReturns 0 if `val` is NULL or type is not string/array/object."]
    #[link_name = "yyjson_mut_get_len__extern"]
    pub fn yyjson_mut_get_len(val: *mut yyjson_mut_val) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is equals to a string.\nThe `str` should be a null-terminated UTF-8 string.\nReturns false if input is NULL or type is not string."]
    #[link_name = "yyjson_mut_equals_str__extern"]
    pub fn yyjson_mut_equals_str(
        val: *mut yyjson_mut_val,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether the JSON value is equals to a string.\nThe `str` should be a UTF-8 string, null-terminator is not required.\nReturns false if input is NULL or type is not string."]
    #[link_name = "yyjson_mut_equals_strn__extern"]
    pub fn yyjson_mut_equals_strn(
        val: *mut yyjson_mut_val,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns whether two JSON values are equal (deep compare).\nReturns false if input is NULL.\n@note the result may be inaccurate if object has duplicate keys.\n@warning This function is recursive and may cause a stack overflow\nif the object level is too deep."]
    #[link_name = "yyjson_mut_equals__extern"]
    pub fn yyjson_mut_equals(lhs: *mut yyjson_mut_val, rhs: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to raw.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_raw__extern"]
    pub fn yyjson_mut_set_raw(
        val: *mut yyjson_mut_val,
        raw: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to null.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_null__extern"]
    pub fn yyjson_mut_set_null(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to bool.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_bool__extern"]
    pub fn yyjson_mut_set_bool(val: *mut yyjson_mut_val, num: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to uint.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_uint__extern"]
    pub fn yyjson_mut_set_uint(val: *mut yyjson_mut_val, num: u64) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to sint.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_sint__extern"]
    pub fn yyjson_mut_set_sint(val: *mut yyjson_mut_val, num: i64) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to int.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_int__extern"]
    pub fn yyjson_mut_set_int(val: *mut yyjson_mut_val, num: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to float.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_float__extern"]
    pub fn yyjson_mut_set_float(val: *mut yyjson_mut_val, num: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to double.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_double__extern"]
    pub fn yyjson_mut_set_double(val: *mut yyjson_mut_val, num: f64) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to real.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_real__extern"]
    pub fn yyjson_mut_set_real(val: *mut yyjson_mut_val, num: f64) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the floating-point number's output format to fixed-point notation.\nReturns false if input is NULL or `val` is not real type.\n@see YYJSON_WRITE_FP_TO_FIXED flag.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_mut_set_fp_to_fixed__extern"]
    pub fn yyjson_mut_set_fp_to_fixed(
        val: *mut yyjson_mut_val,
        prec: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the floating-point number's output format to single-precision.\nReturns false if input is NULL or `val` is not real type.\n@see YYJSON_WRITE_FP_TO_FLOAT flag.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_mut_set_fp_to_float__extern"]
    pub fn yyjson_mut_set_fp_to_float(val: *mut yyjson_mut_val, flt: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to string (null-terminated).\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_str__extern"]
    pub fn yyjson_mut_set_str(
        val: *mut yyjson_mut_val,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to string (with length).\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_strn__extern"]
    pub fn yyjson_mut_set_strn(
        val: *mut yyjson_mut_val,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Marks this string as not needing to be escaped during JSON writing.\nThis can be used to avoid the overhead of escaping if the string contains\nonly characters that do not require escaping.\nReturns false if input is NULL or `val` is not string.\n@see YYJSON_SUBTYPE_NOESC subtype.\n@warning This will modify the `immutable` value, use with caution."]
    #[link_name = "yyjson_mut_set_str_noesc__extern"]
    pub fn yyjson_mut_set_str_noesc(val: *mut yyjson_mut_val, noesc: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to array.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_arr__extern"]
    pub fn yyjson_mut_set_arr(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the value to array.\nReturns false if input is NULL.\n@warning This function should not be used on an existing object or array."]
    #[link_name = "yyjson_mut_set_obj__extern"]
    pub fn yyjson_mut_set_obj(val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates and returns a raw value, returns NULL on error.\nThe `str` should be a null-terminated UTF-8 string.\n\n@warning The input string is not copied, you should keep this string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_raw__extern"]
    pub fn yyjson_mut_raw(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a raw value, returns NULL on error.\nThe `str` should be a UTF-8 string, null-terminator is not required.\n\n@warning The input string is not copied, you should keep this string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_rawn__extern"]
    pub fn yyjson_mut_rawn(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a raw value, returns NULL on error.\nThe `str` should be a null-terminated UTF-8 string.\nThe input string is copied and held by the document."]
    #[link_name = "yyjson_mut_rawcpy__extern"]
    pub fn yyjson_mut_rawcpy(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a raw value, returns NULL on error.\nThe `str` should be a UTF-8 string, null-terminator is not required.\nThe input string is copied and held by the document."]
    #[link_name = "yyjson_mut_rawncpy__extern"]
    pub fn yyjson_mut_rawncpy(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a null value, returns NULL on error."]
    #[link_name = "yyjson_mut_null__extern"]
    pub fn yyjson_mut_null(doc: *mut yyjson_mut_doc) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a true value, returns NULL on error."]
    #[link_name = "yyjson_mut_true__extern"]
    pub fn yyjson_mut_true(doc: *mut yyjson_mut_doc) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a false value, returns NULL on error."]
    #[link_name = "yyjson_mut_false__extern"]
    pub fn yyjson_mut_false(doc: *mut yyjson_mut_doc) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a bool value, returns NULL on error."]
    #[link_name = "yyjson_mut_bool__extern"]
    pub fn yyjson_mut_bool(doc: *mut yyjson_mut_doc, val: bool) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns an unsigned integer value, returns NULL on error."]
    #[link_name = "yyjson_mut_uint__extern"]
    pub fn yyjson_mut_uint(doc: *mut yyjson_mut_doc, num: u64) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a signed integer value, returns NULL on error."]
    #[link_name = "yyjson_mut_sint__extern"]
    pub fn yyjson_mut_sint(doc: *mut yyjson_mut_doc, num: i64) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a signed integer value, returns NULL on error."]
    #[link_name = "yyjson_mut_int__extern"]
    pub fn yyjson_mut_int(doc: *mut yyjson_mut_doc, num: i64) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a float number value, returns NULL on error."]
    #[link_name = "yyjson_mut_float__extern"]
    pub fn yyjson_mut_float(doc: *mut yyjson_mut_doc, num: f32) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a double number value, returns NULL on error."]
    #[link_name = "yyjson_mut_double__extern"]
    pub fn yyjson_mut_double(doc: *mut yyjson_mut_doc, num: f64) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a real number value, returns NULL on error."]
    #[link_name = "yyjson_mut_real__extern"]
    pub fn yyjson_mut_real(doc: *mut yyjson_mut_doc, num: f64) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a string value, returns NULL on error.\nThe `str` should be a null-terminated UTF-8 string.\n@warning The input string is not copied, you should keep this string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_str__extern"]
    pub fn yyjson_mut_str(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a string value, returns NULL on error.\nThe `str` should be a UTF-8 string, null-terminator is not required.\n@warning The input string is not copied, you should keep this string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_strn__extern"]
    pub fn yyjson_mut_strn(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a string value, returns NULL on error.\nThe `str` should be a null-terminated UTF-8 string.\nThe input string is copied and held by the document."]
    #[link_name = "yyjson_mut_strcpy__extern"]
    pub fn yyjson_mut_strcpy(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a string value, returns NULL on error.\nThe `str` should be a UTF-8 string, null-terminator is not required.\nThe input string is copied and held by the document."]
    #[link_name = "yyjson_mut_strncpy__extern"]
    pub fn yyjson_mut_strncpy(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Returns the number of elements in this array.\nReturns 0 if `arr` is NULL or type is not array."]
    #[link_name = "yyjson_mut_arr_size__extern"]
    pub fn yyjson_mut_arr_size(arr: *mut yyjson_mut_val) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the element at the specified position in this array.\nReturns NULL if array is NULL/empty or the index is out of bounds.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_arr_get__extern"]
    pub fn yyjson_mut_arr_get(arr: *mut yyjson_mut_val, idx: usize) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Returns the first element of this array.\nReturns NULL if `arr` is NULL/empty or type is not array."]
    #[link_name = "yyjson_mut_arr_get_first__extern"]
    pub fn yyjson_mut_arr_get_first(arr: *mut yyjson_mut_val) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Returns the last element of this array.\nReturns NULL if `arr` is NULL/empty or type is not array."]
    #[link_name = "yyjson_mut_arr_get_last__extern"]
    pub fn yyjson_mut_arr_get_last(arr: *mut yyjson_mut_val) -> *mut yyjson_mut_val;
}
#[doc = "A mutable JSON array iterator.\n\n@warning You should not modify the array while iterating over it, but you can\nuse `yyjson_mut_arr_iter_remove()` to remove current value.\n\n@par Example\n@code\nyyjson_mut_val *val;\nyyjson_mut_arr_iter iter = yyjson_mut_arr_iter_with(arr);\nwhile ((val = yyjson_mut_arr_iter_next(&iter))) {\nyour_func(val);\nif (your_val_is_unused(val)) {\nyyjson_mut_arr_iter_remove(&iter);\n}\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_mut_arr_iter {
    #[doc = "< next value's index"]
    pub idx: usize,
    #[doc = "< maximum index (arr.size)"]
    pub max: usize,
    #[doc = "< current value"]
    pub cur: *mut yyjson_mut_val,
    #[doc = "< previous value"]
    pub pre: *mut yyjson_mut_val,
    #[doc = "< the array being iterated"]
    pub arr: *mut yyjson_mut_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_mut_arr_iter"][::std::mem::size_of::<yyjson_mut_arr_iter>() - 40usize];
    ["Alignment of yyjson_mut_arr_iter"][::std::mem::align_of::<yyjson_mut_arr_iter>() - 8usize];
    ["Offset of field: yyjson_mut_arr_iter::idx"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, idx) - 0usize];
    ["Offset of field: yyjson_mut_arr_iter::max"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, max) - 8usize];
    ["Offset of field: yyjson_mut_arr_iter::cur"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, cur) - 16usize];
    ["Offset of field: yyjson_mut_arr_iter::pre"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, pre) - 24usize];
    ["Offset of field: yyjson_mut_arr_iter::arr"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, arr) - 32usize];
};
unsafe extern "C" {
    #[doc = "Initialize an iterator for this array.\n\n@param arr The array to be iterated over.\nIf this parameter is NULL or not an array, `iter` will be set to empty.\n@param iter The iterator to be initialized.\nIf this parameter is NULL, the function will fail and return false.\n@return true if the `iter` has been successfully initialized.\n\n@note The iterator does not need to be destroyed."]
    #[link_name = "yyjson_mut_arr_iter_init__extern"]
    pub fn yyjson_mut_arr_iter_init(
        arr: *mut yyjson_mut_val,
        iter: *mut yyjson_mut_arr_iter,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Create an iterator with an array , same as `yyjson_mut_arr_iter_init()`.\n\n@param arr The array to be iterated over.\nIf this parameter is NULL or not an array, an empty iterator will returned.\n@return A new iterator for the array.\n\n@note The iterator does not need to be destroyed."]
    #[link_name = "yyjson_mut_arr_iter_with__extern"]
    pub fn yyjson_mut_arr_iter_with(arr: *mut yyjson_mut_val) -> yyjson_mut_arr_iter;
}
unsafe extern "C" {
    #[doc = "Returns whether the iteration has more elements.\nIf `iter` is NULL, this function will return false."]
    #[link_name = "yyjson_mut_arr_iter_has_next__extern"]
    pub fn yyjson_mut_arr_iter_has_next(iter: *mut yyjson_mut_arr_iter) -> bool;
}
unsafe extern "C" {
    #[doc = "Returns the next element in the iteration, or NULL on end.\nIf `iter` is NULL, this function will return NULL."]
    #[link_name = "yyjson_mut_arr_iter_next__extern"]
    pub fn yyjson_mut_arr_iter_next(iter: *mut yyjson_mut_arr_iter) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes and returns current element in the iteration.\nIf `iter` is NULL, this function will return NULL."]
    #[link_name = "yyjson_mut_arr_iter_remove__extern"]
    pub fn yyjson_mut_arr_iter_remove(iter: *mut yyjson_mut_arr_iter) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns an empty mutable array.\n@param doc A mutable document, used for memory allocation only.\n@return The new array. NULL if input is NULL or memory allocation failed."]
    #[link_name = "yyjson_mut_arr__extern"]
    pub fn yyjson_mut_arr(doc: *mut yyjson_mut_doc) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given boolean values.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of boolean values.\n@param count The value count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst bool vals[3] = { true, false, true };\nyyjson_mut_val *arr = yyjson_mut_arr_with_bool(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_bool__extern"]
    pub fn yyjson_mut_arr_with_bool(
        doc: *mut yyjson_mut_doc,
        vals: *const bool,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given sint numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of sint numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst int64_t vals[3] = { -1, 0, 1 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_sint64(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_sint__extern"]
    pub fn yyjson_mut_arr_with_sint(
        doc: *mut yyjson_mut_doc,
        vals: *const i64,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given uint numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of uint numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst uint64_t vals[3] = { 0, 1, 0 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_uint(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_uint__extern"]
    pub fn yyjson_mut_arr_with_uint(
        doc: *mut yyjson_mut_doc,
        vals: *const u64,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given real numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of real numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst double vals[3] = { 0.1, 0.2, 0.3 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_real(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_real__extern"]
    pub fn yyjson_mut_arr_with_real(
        doc: *mut yyjson_mut_doc,
        vals: *const f64,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given int8 numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of int8 numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst int8_t vals[3] = { -1, 0, 1 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_sint8(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_sint8__extern"]
    pub fn yyjson_mut_arr_with_sint8(
        doc: *mut yyjson_mut_doc,
        vals: *const i8,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given int16 numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of int16 numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst int16_t vals[3] = { -1, 0, 1 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_sint16(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_sint16__extern"]
    pub fn yyjson_mut_arr_with_sint16(
        doc: *mut yyjson_mut_doc,
        vals: *const i16,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given int32 numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of int32 numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst int32_t vals[3] = { -1, 0, 1 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_sint32(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_sint32__extern"]
    pub fn yyjson_mut_arr_with_sint32(
        doc: *mut yyjson_mut_doc,
        vals: *const i32,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given int64 numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of int64 numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst int64_t vals[3] = { -1, 0, 1 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_sint64(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_sint64__extern"]
    pub fn yyjson_mut_arr_with_sint64(
        doc: *mut yyjson_mut_doc,
        vals: *const i64,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given uint8 numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of uint8 numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst uint8_t vals[3] = { 0, 1, 0 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_uint8(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_uint8__extern"]
    pub fn yyjson_mut_arr_with_uint8(
        doc: *mut yyjson_mut_doc,
        vals: *const u8,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given uint16 numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of uint16 numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst uint16_t vals[3] = { 0, 1, 0 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_uint16(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_uint16__extern"]
    pub fn yyjson_mut_arr_with_uint16(
        doc: *mut yyjson_mut_doc,
        vals: *const u16,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given uint32 numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of uint32 numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst uint32_t vals[3] = { 0, 1, 0 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_uint32(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_uint32__extern"]
    pub fn yyjson_mut_arr_with_uint32(
        doc: *mut yyjson_mut_doc,
        vals: *const u32,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given uint64 numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of uint64 numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst uint64_t vals[3] = { 0, 1, 0 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_uint64(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_uint64__extern"]
    pub fn yyjson_mut_arr_with_uint64(
        doc: *mut yyjson_mut_doc,
        vals: *const u64,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given float numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of float numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst float vals[3] = { -1.0f, 0.0f, 1.0f };\nyyjson_mut_val *arr = yyjson_mut_arr_with_float(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_float__extern"]
    pub fn yyjson_mut_arr_with_float(
        doc: *mut yyjson_mut_doc,
        vals: *const f32,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given double numbers.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of double numbers.\n@param count The number count. If this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst double vals[3] = { -1.0, 0.0, 1.0 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_double(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_double__extern"]
    pub fn yyjson_mut_arr_with_double(
        doc: *mut yyjson_mut_doc,
        vals: *const f64,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given strings, these strings\nwill not be copied.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of UTF-8 null-terminator strings.\nIf this array contains NULL, the function will fail and return NULL.\n@param count The number of values in `vals`.\nIf this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@warning The input strings are not copied, you should keep these strings\nunmodified for the lifetime of this JSON document. If these strings will be\nmodified, you should use `yyjson_mut_arr_with_strcpy()` instead.\n\n@par Example\n@code\nconst char *vals[3] = { \"a\", \"b\", \"c\" };\nyyjson_mut_val *arr = yyjson_mut_arr_with_str(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_str__extern"]
    pub fn yyjson_mut_arr_with_str(
        doc: *mut yyjson_mut_doc,
        vals: *mut *const ::std::os::raw::c_char,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given strings and string\nlengths, these strings will not be copied.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of UTF-8 strings, null-terminator is not required.\nIf this array contains NULL, the function will fail and return NULL.\n@param lens A C array of string lengths, in bytes.\n@param count The number of strings in `vals`.\nIf this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@warning The input strings are not copied, you should keep these strings\nunmodified for the lifetime of this JSON document. If these strings will be\nmodified, you should use `yyjson_mut_arr_with_strncpy()` instead.\n\n@par Example\n@code\nconst char *vals[3] = { \"a\", \"bb\", \"c\" };\nconst size_t lens[3] = { 1, 2, 1 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_strn(doc, vals, lens, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_strn__extern"]
    pub fn yyjson_mut_arr_with_strn(
        doc: *mut yyjson_mut_doc,
        vals: *mut *const ::std::os::raw::c_char,
        lens: *const usize,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given strings, these strings\nwill be copied.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of UTF-8 null-terminator strings.\nIf this array contains NULL, the function will fail and return NULL.\n@param count The number of values in `vals`.\nIf this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst char *vals[3] = { \"a\", \"b\", \"c\" };\nyyjson_mut_val *arr = yyjson_mut_arr_with_strcpy(doc, vals, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_strcpy__extern"]
    pub fn yyjson_mut_arr_with_strcpy(
        doc: *mut yyjson_mut_doc,
        vals: *mut *const ::std::os::raw::c_char,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a new mutable array with the given strings and string\nlengths, these strings will be copied.\n\n@param doc A mutable document, used for memory allocation only.\nIf this parameter is NULL, the function will fail and return NULL.\n@param vals A C array of UTF-8 strings, null-terminator is not required.\nIf this array contains NULL, the function will fail and return NULL.\n@param lens A C array of string lengths, in bytes.\n@param count The number of strings in `vals`.\nIf this value is 0, an empty array will return.\n@return The new array. NULL if input is invalid or memory allocation failed.\n\n@par Example\n@code\nconst char *vals[3] = { \"a\", \"bb\", \"c\" };\nconst size_t lens[3] = { 1, 2, 1 };\nyyjson_mut_val *arr = yyjson_mut_arr_with_strn(doc, vals, lens, 3);\n@endcode"]
    #[link_name = "yyjson_mut_arr_with_strncpy__extern"]
    pub fn yyjson_mut_arr_with_strncpy(
        doc: *mut yyjson_mut_doc,
        vals: *mut *const ::std::os::raw::c_char,
        lens: *const usize,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Inserts a value into an array at a given index.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param val The value to be inserted. Returns false if it is NULL.\n@param idx The index to which to insert the new value.\nReturns false if the index is out of range.\n@return Whether successful.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_arr_insert__extern"]
    pub fn yyjson_mut_arr_insert(
        arr: *mut yyjson_mut_val,
        val: *mut yyjson_mut_val,
        idx: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Inserts a value at the end of the array.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param val The value to be inserted. Returns false if it is NULL.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_append__extern"]
    pub fn yyjson_mut_arr_append(arr: *mut yyjson_mut_val, val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = "Inserts a value at the head of the array.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param val The value to be inserted. Returns false if it is NULL.\n@return    Whether successful."]
    #[link_name = "yyjson_mut_arr_prepend__extern"]
    pub fn yyjson_mut_arr_prepend(arr: *mut yyjson_mut_val, val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = "Replaces a value at index and returns old value.\n@param arr The array to which the value is to be replaced.\nReturns false if it is NULL or not an array.\n@param idx The index to which to replace the value.\nReturns false if the index is out of range.\n@param val The new value to replace. Returns false if it is NULL.\n@return Old value, or NULL on error.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_arr_replace__extern"]
    pub fn yyjson_mut_arr_replace(
        arr: *mut yyjson_mut_val,
        idx: usize,
        val: *mut yyjson_mut_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes and returns a value at index.\n@param arr The array from which the value is to be removed.\nReturns false if it is NULL or not an array.\n@param idx The index from which to remove the value.\nReturns false if the index is out of range.\n@return Old value, or NULL on error.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_arr_remove__extern"]
    pub fn yyjson_mut_arr_remove(arr: *mut yyjson_mut_val, idx: usize) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes and returns the first value in this array.\n@param arr The array from which the value is to be removed.\nReturns false if it is NULL or not an array.\n@return The first value, or NULL on error."]
    #[link_name = "yyjson_mut_arr_remove_first__extern"]
    pub fn yyjson_mut_arr_remove_first(arr: *mut yyjson_mut_val) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes and returns the last value in this array.\n@param arr The array from which the value is to be removed.\nReturns false if it is NULL or not an array.\n@return The last value, or NULL on error."]
    #[link_name = "yyjson_mut_arr_remove_last__extern"]
    pub fn yyjson_mut_arr_remove_last(arr: *mut yyjson_mut_val) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes all values within a specified range in the array.\n@param arr The array from which the value is to be removed.\nReturns false if it is NULL or not an array.\n@param idx The start index of the range (0 is the first).\n@param len The number of items in the range (can be 0).\n@return Whether successful.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_arr_remove_range__extern"]
    pub fn yyjson_mut_arr_remove_range(arr: *mut yyjson_mut_val, idx: usize, len: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Removes all values in this array.\n@param arr The array from which all of the values are to be removed.\nReturns false if it is NULL or not an array.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_clear__extern"]
    pub fn yyjson_mut_arr_clear(arr: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = "Rotates values in this array for the given number of times.\nFor example: `[1,2,3,4,5]` rotate 2 is `[3,4,5,1,2]`.\n@param arr The array to be rotated.\n@param idx Index (or times) to rotate.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_arr_rotate__extern"]
    pub fn yyjson_mut_arr_rotate(arr: *mut yyjson_mut_val, idx: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a value at the end of the array.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param val The value to be inserted. Returns false if it is NULL.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_val__extern"]
    pub fn yyjson_mut_arr_add_val(arr: *mut yyjson_mut_val, val: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a `null` value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_null__extern"]
    pub fn yyjson_mut_arr_add_null(doc: *mut yyjson_mut_doc, arr: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a `true` value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_true__extern"]
    pub fn yyjson_mut_arr_add_true(doc: *mut yyjson_mut_doc, arr: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a `false` value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_false__extern"]
    pub fn yyjson_mut_arr_add_false(doc: *mut yyjson_mut_doc, arr: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a bool value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param val The bool value to be added.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_bool__extern"]
    pub fn yyjson_mut_arr_add_bool(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        val: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds an unsigned integer value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param num The number to be added.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_uint__extern"]
    pub fn yyjson_mut_arr_add_uint(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        num: u64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a signed integer value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param num The number to be added.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_sint__extern"]
    pub fn yyjson_mut_arr_add_sint(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        num: i64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds an integer value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param num The number to be added.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_int__extern"]
    pub fn yyjson_mut_arr_add_int(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        num: i64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a float value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param num The number to be added.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_float__extern"]
    pub fn yyjson_mut_arr_add_float(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        num: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a double value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param num The number to be added.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_double__extern"]
    pub fn yyjson_mut_arr_add_double(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        num: f64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a double value at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param num The number to be added.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_real__extern"]
    pub fn yyjson_mut_arr_add_real(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        num: f64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a string value at the end of the array (no copy).\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param str A null-terminated UTF-8 string.\n@return Whether successful.\n@warning The input string is not copied, you should keep this string unmodified\nfor the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_arr_add_str__extern"]
    pub fn yyjson_mut_arr_add_str(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a string value at the end of the array (no copy).\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param str A UTF-8 string, null-terminator is not required.\n@param len The length of the string, in bytes.\n@return Whether successful.\n@warning The input string is not copied, you should keep this string unmodified\nfor the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_arr_add_strn__extern"]
    pub fn yyjson_mut_arr_add_strn(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a string value at the end of the array (copied).\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param str A null-terminated UTF-8 string.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_strcpy__extern"]
    pub fn yyjson_mut_arr_add_strcpy(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Adds a string value at the end of the array (copied).\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@param str A UTF-8 string, null-terminator is not required.\n@param len The length of the string, in bytes.\n@return Whether successful."]
    #[link_name = "yyjson_mut_arr_add_strncpy__extern"]
    pub fn yyjson_mut_arr_add_strncpy(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Creates and adds a new array at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@return The new array, or NULL on error."]
    #[link_name = "yyjson_mut_arr_add_arr__extern"]
    pub fn yyjson_mut_arr_add_arr(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and adds a new object at the end of the array.\n@param doc The `doc` is only used for memory allocation.\n@param arr The array to which the value is to be inserted.\nReturns false if it is NULL or not an array.\n@return The new object, or NULL on error."]
    #[link_name = "yyjson_mut_arr_add_obj__extern"]
    pub fn yyjson_mut_arr_add_obj(
        doc: *mut yyjson_mut_doc,
        arr: *mut yyjson_mut_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Returns the number of key-value pairs in this object.\nReturns 0 if `obj` is NULL or type is not object."]
    #[link_name = "yyjson_mut_obj_size__extern"]
    pub fn yyjson_mut_obj_size(obj: *mut yyjson_mut_val) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the value to which the specified key is mapped.\nReturns NULL if this object contains no mapping for the key.\nReturns NULL if `obj/key` is NULL, or type is not object.\n\nThe `key` should be a null-terminated UTF-8 string.\n\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_get__extern"]
    pub fn yyjson_mut_obj_get(
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Returns the value to which the specified key is mapped.\nReturns NULL if this object contains no mapping for the key.\nReturns NULL if `obj/key` is NULL, or type is not object.\n\nThe `key` should be a UTF-8 string, null-terminator is not required.\nThe `key_len` should be the length of the key, in bytes.\n\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_getn__extern"]
    pub fn yyjson_mut_obj_getn(
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        key_len: usize,
    ) -> *mut yyjson_mut_val;
}
#[doc = "A mutable JSON object iterator.\n\n@warning You should not modify the object while iterating over it, but you can\nuse `yyjson_mut_obj_iter_remove()` to remove current value.\n\n@par Example\n@code\nyyjson_mut_val *key, *val;\nyyjson_mut_obj_iter iter = yyjson_mut_obj_iter_with(obj);\nwhile ((key = yyjson_mut_obj_iter_next(&iter))) {\nval = yyjson_mut_obj_iter_get_val(key);\nyour_func(key, val);\nif (your_val_is_unused(key, val)) {\nyyjson_mut_obj_iter_remove(&iter);\n}\n}\n@endcode\n\nIf the ordering of the keys is known at compile-time, you can use this method\nto speed up value lookups:\n@code\n// {\"k1\":1, \"k2\": 3, \"k3\": 3}\nyyjson_mut_val *key, *val;\nyyjson_mut_obj_iter iter = yyjson_mut_obj_iter_with(obj);\nyyjson_mut_val *v1 = yyjson_mut_obj_iter_get(&iter, \"k1\");\nyyjson_mut_val *v3 = yyjson_mut_obj_iter_get(&iter, \"k3\");\n@endcode\n@see `yyjson_mut_obj_iter_get()` and `yyjson_mut_obj_iter_getn()`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_mut_obj_iter {
    #[doc = "< next key's index"]
    pub idx: usize,
    #[doc = "< maximum key index (obj.size)"]
    pub max: usize,
    #[doc = "< current key"]
    pub cur: *mut yyjson_mut_val,
    #[doc = "< previous key"]
    pub pre: *mut yyjson_mut_val,
    #[doc = "< the object being iterated"]
    pub obj: *mut yyjson_mut_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_mut_obj_iter"][::std::mem::size_of::<yyjson_mut_obj_iter>() - 40usize];
    ["Alignment of yyjson_mut_obj_iter"][::std::mem::align_of::<yyjson_mut_obj_iter>() - 8usize];
    ["Offset of field: yyjson_mut_obj_iter::idx"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, idx) - 0usize];
    ["Offset of field: yyjson_mut_obj_iter::max"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, max) - 8usize];
    ["Offset of field: yyjson_mut_obj_iter::cur"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, cur) - 16usize];
    ["Offset of field: yyjson_mut_obj_iter::pre"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, pre) - 24usize];
    ["Offset of field: yyjson_mut_obj_iter::obj"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, obj) - 32usize];
};
unsafe extern "C" {
    #[doc = "Initialize an iterator for this object.\n\n@param obj The object to be iterated over.\nIf this parameter is NULL or not an array, `iter` will be set to empty.\n@param iter The iterator to be initialized.\nIf this parameter is NULL, the function will fail and return false.\n@return true if the `iter` has been successfully initialized.\n\n@note The iterator does not need to be destroyed."]
    #[link_name = "yyjson_mut_obj_iter_init__extern"]
    pub fn yyjson_mut_obj_iter_init(
        obj: *mut yyjson_mut_val,
        iter: *mut yyjson_mut_obj_iter,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Create an iterator with an object, same as `yyjson_obj_iter_init()`.\n\n@param obj The object to be iterated over.\nIf this parameter is NULL or not an object, an empty iterator will returned.\n@return A new iterator for the object.\n\n@note The iterator does not need to be destroyed."]
    #[link_name = "yyjson_mut_obj_iter_with__extern"]
    pub fn yyjson_mut_obj_iter_with(obj: *mut yyjson_mut_val) -> yyjson_mut_obj_iter;
}
unsafe extern "C" {
    #[doc = "Returns whether the iteration has more elements.\nIf `iter` is NULL, this function will return false."]
    #[link_name = "yyjson_mut_obj_iter_has_next__extern"]
    pub fn yyjson_mut_obj_iter_has_next(iter: *mut yyjson_mut_obj_iter) -> bool;
}
unsafe extern "C" {
    #[doc = "Returns the next key in the iteration, or NULL on end.\nIf `iter` is NULL, this function will return NULL."]
    #[link_name = "yyjson_mut_obj_iter_next__extern"]
    pub fn yyjson_mut_obj_iter_next(iter: *mut yyjson_mut_obj_iter) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Returns the value for key inside the iteration.\nIf `iter` is NULL, this function will return NULL."]
    #[link_name = "yyjson_mut_obj_iter_get_val__extern"]
    pub fn yyjson_mut_obj_iter_get_val(key: *mut yyjson_mut_val) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes current key-value pair in the iteration, returns the removed value.\nIf `iter` is NULL, this function will return NULL."]
    #[link_name = "yyjson_mut_obj_iter_remove__extern"]
    pub fn yyjson_mut_obj_iter_remove(iter: *mut yyjson_mut_obj_iter) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Iterates to a specified key and returns the value.\n\nThis function does the same thing as `yyjson_mut_obj_get()`, but is much faster\nif the ordering of the keys is known at compile-time and you are using the same\norder to look up the values. If the key exists in this object, then the\niterator will stop at the next key, otherwise the iterator will not change and\nNULL is returned.\n\n@param iter The object iterator, should not be NULL.\n@param key The key, should be a UTF-8 string with null-terminator.\n@return The value to which the specified key is mapped.\nNULL if this object contains no mapping for the key or input is invalid.\n\n@warning This function takes a linear search time if the key is not nearby."]
    #[link_name = "yyjson_mut_obj_iter_get__extern"]
    pub fn yyjson_mut_obj_iter_get(
        iter: *mut yyjson_mut_obj_iter,
        key: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Iterates to a specified key and returns the value.\n\nThis function does the same thing as `yyjson_mut_obj_getn()` but is much faster\nif the ordering of the keys is known at compile-time and you are using the same\norder to look up the values. If the key exists in this object, then the\niterator will stop at the next key, otherwise the iterator will not change and\nNULL is returned.\n\n@param iter The object iterator, should not be NULL.\n@param key The key, should be a UTF-8 string, null-terminator is not required.\n@param key_len The the length of `key`, in bytes.\n@return The value to which the specified key is mapped.\nNULL if this object contains no mapping for the key or input is invalid.\n\n@warning This function takes a linear search time if the key is not nearby."]
    #[link_name = "yyjson_mut_obj_iter_getn__extern"]
    pub fn yyjson_mut_obj_iter_getn(
        iter: *mut yyjson_mut_obj_iter,
        key: *const ::std::os::raw::c_char,
        key_len: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Creates and returns a mutable object, returns NULL on error."]
    #[link_name = "yyjson_mut_obj__extern"]
    pub fn yyjson_mut_obj(doc: *mut yyjson_mut_doc) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a mutable object with keys and values, returns NULL on\nerror. The keys and values are not copied. The strings should be a\nnull-terminated UTF-8 string.\n\n@warning The input string is not copied, you should keep this string\nunmodified for the lifetime of this JSON document.\n\n@par Example\n@code\nconst char *keys[2] = { \"id\", \"name\" };\nconst char *vals[2] = { \"01\", \"Harry\" };\nyyjson_mut_val *obj = yyjson_mut_obj_with_str(doc, keys, vals, 2);\n@endcode"]
    #[link_name = "yyjson_mut_obj_with_str__extern"]
    pub fn yyjson_mut_obj_with_str(
        doc: *mut yyjson_mut_doc,
        keys: *mut *const ::std::os::raw::c_char,
        vals: *mut *const ::std::os::raw::c_char,
        count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a mutable object with key-value pairs and pair count,\nreturns NULL on error. The keys and values are not copied. The strings should\nbe a null-terminated UTF-8 string.\n\n@warning The input string is not copied, you should keep this string\nunmodified for the lifetime of this JSON document.\n\n@par Example\n@code\nconst char *kv_pairs[4] = { \"id\", \"01\", \"name\", \"Harry\" };\nyyjson_mut_val *obj = yyjson_mut_obj_with_kv(doc, kv_pairs, 2);\n@endcode"]
    #[link_name = "yyjson_mut_obj_with_kv__extern"]
    pub fn yyjson_mut_obj_with_kv(
        doc: *mut yyjson_mut_doc,
        kv_pairs: *mut *const ::std::os::raw::c_char,
        pair_count: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Adds a key-value pair at the end of the object.\nThis function allows duplicated key in one object.\n@param obj The object to which the new key-value pair is to be added.\n@param key The key, should be a string which is created by `yyjson_mut_str()`,\n`yyjson_mut_strn()`, `yyjson_mut_strcpy()` or `yyjson_mut_strncpy()`.\n@param val The value to add to the object.\n@return Whether successful."]
    #[link_name = "yyjson_mut_obj_add__extern"]
    pub fn yyjson_mut_obj_add(
        obj: *mut yyjson_mut_val,
        key: *mut yyjson_mut_val,
        val: *mut yyjson_mut_val,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets a key-value pair at the end of the object.\nThis function may remove all key-value pairs for the given key before add.\n@param obj The object to which the new key-value pair is to be added.\n@param key The key, should be a string which is created by `yyjson_mut_str()`,\n`yyjson_mut_strn()`, `yyjson_mut_strcpy()` or `yyjson_mut_strncpy()`.\n@param val The value to add to the object. If this value is null, the behavior\nis same as `yyjson_mut_obj_remove()`.\n@return Whether successful."]
    #[link_name = "yyjson_mut_obj_put__extern"]
    pub fn yyjson_mut_obj_put(
        obj: *mut yyjson_mut_val,
        key: *mut yyjson_mut_val,
        val: *mut yyjson_mut_val,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Inserts a key-value pair to the object at the given position.\nThis function allows duplicated key in one object.\n@param obj The object to which the new key-value pair is to be added.\n@param key The key, should be a string which is created by `yyjson_mut_str()`,\n`yyjson_mut_strn()`, `yyjson_mut_strcpy()` or `yyjson_mut_strncpy()`.\n@param val The value to add to the object.\n@param idx The index to which to insert the new pair.\n@return Whether successful."]
    #[link_name = "yyjson_mut_obj_insert__extern"]
    pub fn yyjson_mut_obj_insert(
        obj: *mut yyjson_mut_val,
        key: *mut yyjson_mut_val,
        val: *mut yyjson_mut_val,
        idx: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Removes all key-value pair from the object with given key.\n@param obj The object from which the key-value pair is to be removed.\n@param key The key, should be a string value.\n@return The first matched value, or NULL if no matched value.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_remove__extern"]
    pub fn yyjson_mut_obj_remove(
        obj: *mut yyjson_mut_val,
        key: *mut yyjson_mut_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes all key-value pair from the object with given key.\n@param obj The object from which the key-value pair is to be removed.\n@param key The key, should be a UTF-8 string with null-terminator.\n@return The first matched value, or NULL if no matched value.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_remove_key__extern"]
    pub fn yyjson_mut_obj_remove_key(
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes all key-value pair from the object with given key.\n@param obj The object from which the key-value pair is to be removed.\n@param key The key, should be a UTF-8 string, null-terminator is not required.\n@param key_len The length of the key.\n@return The first matched value, or NULL if no matched value.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_remove_keyn__extern"]
    pub fn yyjson_mut_obj_remove_keyn(
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        key_len: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Removes all key-value pairs in this object.\n@param obj The object from which all of the values are to be removed.\n@return Whether successful."]
    #[link_name = "yyjson_mut_obj_clear__extern"]
    pub fn yyjson_mut_obj_clear(obj: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[doc = "Replaces value from the object with given key.\nIf the key is not exist, or the value is NULL, it will fail.\n@param obj The object to which the value is to be replaced.\n@param key The key, should be a string value.\n@param val The value to replace into the object.\n@return Whether successful.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_replace__extern"]
    pub fn yyjson_mut_obj_replace(
        obj: *mut yyjson_mut_val,
        key: *mut yyjson_mut_val,
        val: *mut yyjson_mut_val,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Rotates key-value pairs in the object for the given number of times.\nFor example: `{\"a\":1,\"b\":2,\"c\":3,\"d\":4}` rotate 1 is\n`{\"b\":2,\"c\":3,\"d\":4,\"a\":1}`.\n@param obj The object to be rotated.\n@param idx Index (or times) to rotate.\n@return Whether successful.\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_rotate__extern"]
    pub fn yyjson_mut_obj_rotate(obj: *mut yyjson_mut_val, idx: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a `null` value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_null__extern"]
    pub fn yyjson_mut_obj_add_null(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a `true` value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_true__extern"]
    pub fn yyjson_mut_obj_add_true(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a `false` value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_false__extern"]
    pub fn yyjson_mut_obj_add_false(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a bool value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_bool__extern"]
    pub fn yyjson_mut_obj_add_bool(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds an unsigned integer value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_uint__extern"]
    pub fn yyjson_mut_obj_add_uint(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: u64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a signed integer value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_sint__extern"]
    pub fn yyjson_mut_obj_add_sint(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: i64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds an int value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_int__extern"]
    pub fn yyjson_mut_obj_add_int(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: i64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a float value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_float__extern"]
    pub fn yyjson_mut_obj_add_float(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a double value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_double__extern"]
    pub fn yyjson_mut_obj_add_double(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: f64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a real value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_real__extern"]
    pub fn yyjson_mut_obj_add_real(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: f64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a string value at the end of the object.\nThe `key` and `val` should be null-terminated UTF-8 strings.\nThis function allows duplicated key in one object.\n\n@warning The key/value strings are not copied, you should keep these strings\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_str__extern"]
    pub fn yyjson_mut_obj_add_str(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a string value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThe `val` should be a UTF-8 string, null-terminator is not required.\nThe `len` should be the length of the `val`, in bytes.\nThis function allows duplicated key in one object.\n\n@warning The key/value strings are not copied, you should keep these strings\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_strn__extern"]
    pub fn yyjson_mut_obj_add_strn(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a string value at the end of the object.\nThe `key` and `val` should be null-terminated UTF-8 strings.\nThe value string is copied.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_strcpy__extern"]
    pub fn yyjson_mut_obj_add_strcpy(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Adds a string value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThe `val` should be a UTF-8 string, null-terminator is not required.\nThe `len` should be the length of the `val`, in bytes.\nThis function allows duplicated key in one object.\n\n@warning The key strings are not copied, you should keep these strings\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_strncpy__extern"]
    pub fn yyjson_mut_obj_add_strncpy(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Creates and adds a new array to the target object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep these strings\nunmodified for the lifetime of this JSON document.\n@return The new array, or NULL on error."]
    #[link_name = "yyjson_mut_obj_add_arr__extern"]
    pub fn yyjson_mut_obj_add_arr(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and adds a new object to the target object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep these strings\nunmodified for the lifetime of this JSON document.\n@return The new object, or NULL on error."]
    #[link_name = "yyjson_mut_obj_add_obj__extern"]
    pub fn yyjson_mut_obj_add_obj(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Adds a JSON value at the end of the object.\nThe `key` should be a null-terminated UTF-8 string.\nThis function allows duplicated key in one object.\n\n@warning The key string is not copied, you should keep the string\nunmodified for the lifetime of this JSON document."]
    #[link_name = "yyjson_mut_obj_add_val__extern"]
    pub fn yyjson_mut_obj_add_val(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        val: *mut yyjson_mut_val,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Removes all key-value pairs for the given key.\nReturns the first value to which the specified key is mapped or NULL if this\nobject contains no mapping for the key.\nThe `key` should be a null-terminated UTF-8 string.\n\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_remove_str__extern"]
    pub fn yyjson_mut_obj_remove_str(
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Removes all key-value pairs for the given key.\nReturns the first value to which the specified key is mapped or NULL if this\nobject contains no mapping for the key.\nThe `key` should be a UTF-8 string, null-terminator is not required.\nThe `len` should be the length of the key, in bytes.\n\n@warning This function takes a linear search time."]
    #[link_name = "yyjson_mut_obj_remove_strn__extern"]
    pub fn yyjson_mut_obj_remove_strn(
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Replaces all matching keys with the new key.\nReturns true if at least one key was renamed.\nThe `key` and `new_key` should be a null-terminated UTF-8 string.\nThe `new_key` is copied and held by doc.\n\n@warning This function takes a linear search time.\nIf `new_key` already exists, it will cause duplicate keys."]
    #[link_name = "yyjson_mut_obj_rename_key__extern"]
    pub fn yyjson_mut_obj_rename_key(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        new_key: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Replaces all matching keys with the new key.\nReturns true if at least one key was renamed.\nThe `key` and `new_key` should be a UTF-8 string,\nnull-terminator is not required. The `new_key` is copied and held by doc.\n\n@warning This function takes a linear search time.\nIf `new_key` already exists, it will cause duplicate keys."]
    #[link_name = "yyjson_mut_obj_rename_keyn__extern"]
    pub fn yyjson_mut_obj_rename_keyn(
        doc: *mut yyjson_mut_doc,
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        len: usize,
        new_key: *const ::std::os::raw::c_char,
        new_len: usize,
    ) -> bool;
}
#[doc = " Payload of a JSON value (8 bytes)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union yyjson_val_uni {
    pub u64_: u64,
    pub i64_: i64,
    pub f64_: f64,
    pub str_: *const ::std::os::raw::c_char,
    pub ptr: *mut ::std::os::raw::c_void,
    pub ofs: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_val_uni"][::std::mem::size_of::<yyjson_val_uni>() - 8usize];
    ["Alignment of yyjson_val_uni"][::std::mem::align_of::<yyjson_val_uni>() - 8usize];
    ["Offset of field: yyjson_val_uni::u64_"]
        [::std::mem::offset_of!(yyjson_val_uni, u64_) - 0usize];
    ["Offset of field: yyjson_val_uni::i64_"]
        [::std::mem::offset_of!(yyjson_val_uni, i64_) - 0usize];
    ["Offset of field: yyjson_val_uni::f64_"]
        [::std::mem::offset_of!(yyjson_val_uni, f64_) - 0usize];
    ["Offset of field: yyjson_val_uni::str_"]
        [::std::mem::offset_of!(yyjson_val_uni, str_) - 0usize];
    ["Offset of field: yyjson_val_uni::ptr"][::std::mem::offset_of!(yyjson_val_uni, ptr) - 0usize];
    ["Offset of field: yyjson_val_uni::ofs"][::std::mem::offset_of!(yyjson_val_uni, ofs) - 0usize];
};
#[doc = "Immutable JSON value, 16 bytes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct yyjson_val {
    #[doc = "< type, subtype and length"]
    pub tag: u64,
    #[doc = "< payload"]
    pub uni: yyjson_val_uni,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_val"][::std::mem::size_of::<yyjson_val>() - 16usize];
    ["Alignment of yyjson_val"][::std::mem::align_of::<yyjson_val>() - 8usize];
    ["Offset of field: yyjson_val::tag"][::std::mem::offset_of!(yyjson_val, tag) - 0usize];
    ["Offset of field: yyjson_val::uni"][::std::mem::offset_of!(yyjson_val, uni) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_doc {
    #[doc = " Root value of the document (nonnull)."]
    pub root: *mut yyjson_val,
    #[doc = " Allocator used by document (nonnull)."]
    pub alc: yyjson_alc,
    #[doc = " The total number of bytes read when parsing JSON (nonzero)."]
    pub dat_read: usize,
    #[doc = " The total number of value read when parsing JSON (nonzero)."]
    pub val_read: usize,
    #[doc = " The string pool used by JSON values (nullable)."]
    pub str_pool: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_doc"][::std::mem::size_of::<yyjson_doc>() - 64usize];
    ["Alignment of yyjson_doc"][::std::mem::align_of::<yyjson_doc>() - 8usize];
    ["Offset of field: yyjson_doc::root"][::std::mem::offset_of!(yyjson_doc, root) - 0usize];
    ["Offset of field: yyjson_doc::alc"][::std::mem::offset_of!(yyjson_doc, alc) - 8usize];
    ["Offset of field: yyjson_doc::dat_read"]
        [::std::mem::offset_of!(yyjson_doc, dat_read) - 40usize];
    ["Offset of field: yyjson_doc::val_read"]
        [::std::mem::offset_of!(yyjson_doc, val_read) - 48usize];
    ["Offset of field: yyjson_doc::str_pool"]
        [::std::mem::offset_of!(yyjson_doc, str_pool) - 56usize];
};
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_str_noesc__extern"]
    pub fn unsafe_yyjson_is_str_noesc(str_: *const ::std::os::raw::c_char, len: usize) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_u64_to_f64__extern"]
    pub fn unsafe_yyjson_u64_to_f64(num: u64) -> f64;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_type__extern"]
    pub fn unsafe_yyjson_get_type(val: *mut ::std::os::raw::c_void) -> yyjson_type;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_subtype__extern"]
    pub fn unsafe_yyjson_get_subtype(val: *mut ::std::os::raw::c_void) -> yyjson_subtype;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_tag__extern"]
    pub fn unsafe_yyjson_get_tag(val: *mut ::std::os::raw::c_void) -> u8;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_raw__extern"]
    pub fn unsafe_yyjson_is_raw(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_null__extern"]
    pub fn unsafe_yyjson_is_null(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_bool__extern"]
    pub fn unsafe_yyjson_is_bool(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_num__extern"]
    pub fn unsafe_yyjson_is_num(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_str__extern"]
    pub fn unsafe_yyjson_is_str(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_arr__extern"]
    pub fn unsafe_yyjson_is_arr(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_obj__extern"]
    pub fn unsafe_yyjson_is_obj(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_ctn__extern"]
    pub fn unsafe_yyjson_is_ctn(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_uint__extern"]
    pub fn unsafe_yyjson_is_uint(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_sint__extern"]
    pub fn unsafe_yyjson_is_sint(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_int__extern"]
    pub fn unsafe_yyjson_is_int(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_real__extern"]
    pub fn unsafe_yyjson_is_real(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_true__extern"]
    pub fn unsafe_yyjson_is_true(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_is_false__extern"]
    pub fn unsafe_yyjson_is_false(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_arr_is_flat__extern"]
    pub fn unsafe_yyjson_arr_is_flat(val: *mut yyjson_val) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_raw__extern"]
    pub fn unsafe_yyjson_get_raw(val: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_bool__extern"]
    pub fn unsafe_yyjson_get_bool(val: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_uint__extern"]
    pub fn unsafe_yyjson_get_uint(val: *mut ::std::os::raw::c_void) -> u64;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_sint__extern"]
    pub fn unsafe_yyjson_get_sint(val: *mut ::std::os::raw::c_void) -> i64;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_int__extern"]
    pub fn unsafe_yyjson_get_int(val: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_real__extern"]
    pub fn unsafe_yyjson_get_real(val: *mut ::std::os::raw::c_void) -> f64;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_num__extern"]
    pub fn unsafe_yyjson_get_num(val: *mut ::std::os::raw::c_void) -> f64;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_str__extern"]
    pub fn unsafe_yyjson_get_str(val: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_len__extern"]
    pub fn unsafe_yyjson_get_len(val: *mut ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_first__extern"]
    pub fn unsafe_yyjson_get_first(ctn: *mut yyjson_val) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_get_next__extern"]
    pub fn unsafe_yyjson_get_next(val: *mut yyjson_val) -> *mut yyjson_val;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_equals_strn__extern"]
    pub fn unsafe_yyjson_equals_strn(
        val: *mut ::std::os::raw::c_void,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_equals_str__extern"]
    pub fn unsafe_yyjson_equals_str(
        val: *mut ::std::os::raw::c_void,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_type__extern"]
    pub fn unsafe_yyjson_set_type(
        val: *mut ::std::os::raw::c_void,
        type_: yyjson_type,
        subtype: yyjson_subtype,
    );
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_len__extern"]
    pub fn unsafe_yyjson_set_len(val: *mut ::std::os::raw::c_void, len: usize);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_tag__extern"]
    pub fn unsafe_yyjson_set_tag(
        val: *mut ::std::os::raw::c_void,
        type_: yyjson_type,
        subtype: yyjson_subtype,
        len: usize,
    );
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_inc_len__extern"]
    pub fn unsafe_yyjson_inc_len(val: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_raw__extern"]
    pub fn unsafe_yyjson_set_raw(
        val: *mut ::std::os::raw::c_void,
        raw: *const ::std::os::raw::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_null__extern"]
    pub fn unsafe_yyjson_set_null(val: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_bool__extern"]
    pub fn unsafe_yyjson_set_bool(val: *mut ::std::os::raw::c_void, num: bool);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_uint__extern"]
    pub fn unsafe_yyjson_set_uint(val: *mut ::std::os::raw::c_void, num: u64);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_sint__extern"]
    pub fn unsafe_yyjson_set_sint(val: *mut ::std::os::raw::c_void, num: i64);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_fp_to_fixed__extern"]
    pub fn unsafe_yyjson_set_fp_to_fixed(
        val: *mut ::std::os::raw::c_void,
        prec: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_fp_to_float__extern"]
    pub fn unsafe_yyjson_set_fp_to_float(val: *mut ::std::os::raw::c_void, flt: bool);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_float__extern"]
    pub fn unsafe_yyjson_set_float(val: *mut ::std::os::raw::c_void, num: f32);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_double__extern"]
    pub fn unsafe_yyjson_set_double(val: *mut ::std::os::raw::c_void, num: f64);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_real__extern"]
    pub fn unsafe_yyjson_set_real(val: *mut ::std::os::raw::c_void, num: f64);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_str_noesc__extern"]
    pub fn unsafe_yyjson_set_str_noesc(val: *mut ::std::os::raw::c_void, noesc: bool);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_strn__extern"]
    pub fn unsafe_yyjson_set_strn(
        val: *mut ::std::os::raw::c_void,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_str__extern"]
    pub fn unsafe_yyjson_set_str(
        val: *mut ::std::os::raw::c_void,
        str_: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_arr__extern"]
    pub fn unsafe_yyjson_set_arr(val: *mut ::std::os::raw::c_void, size: usize);
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_set_obj__extern"]
    pub fn unsafe_yyjson_set_obj(val: *mut ::std::os::raw::c_void, size: usize);
}
unsafe extern "C" {
    pub fn unsafe_yyjson_equals(lhs: *mut yyjson_val, rhs: *mut yyjson_val) -> bool;
}
#[doc = "Mutable JSON value, 24 bytes.\nThe 'tag' and 'uni' field is same as immutable value.\nThe 'next' field links all elements inside the container to be a cycle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct yyjson_mut_val {
    #[doc = "< type, subtype and length"]
    pub tag: u64,
    #[doc = "< payload"]
    pub uni: yyjson_val_uni,
    #[doc = "< the next value in circular linked list"]
    pub next: *mut yyjson_mut_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_mut_val"][::std::mem::size_of::<yyjson_mut_val>() - 24usize];
    ["Alignment of yyjson_mut_val"][::std::mem::align_of::<yyjson_mut_val>() - 8usize];
    ["Offset of field: yyjson_mut_val::tag"][::std::mem::offset_of!(yyjson_mut_val, tag) - 0usize];
    ["Offset of field: yyjson_mut_val::uni"][::std::mem::offset_of!(yyjson_mut_val, uni) - 8usize];
    ["Offset of field: yyjson_mut_val::next"]
        [::std::mem::offset_of!(yyjson_mut_val, next) - 16usize];
};
#[doc = "A memory chunk in string memory pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_str_chunk {
    pub next: *mut yyjson_str_chunk,
    pub chunk_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_str_chunk"][::std::mem::size_of::<yyjson_str_chunk>() - 16usize];
    ["Alignment of yyjson_str_chunk"][::std::mem::align_of::<yyjson_str_chunk>() - 8usize];
    ["Offset of field: yyjson_str_chunk::next"]
        [::std::mem::offset_of!(yyjson_str_chunk, next) - 0usize];
    ["Offset of field: yyjson_str_chunk::chunk_size"]
        [::std::mem::offset_of!(yyjson_str_chunk, chunk_size) - 8usize];
};
#[doc = "A memory pool to hold all strings in a mutable document."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_str_pool {
    pub cur: *mut ::std::os::raw::c_char,
    pub end: *mut ::std::os::raw::c_char,
    pub chunk_size: usize,
    pub chunk_size_max: usize,
    pub chunks: *mut yyjson_str_chunk,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_str_pool"][::std::mem::size_of::<yyjson_str_pool>() - 40usize];
    ["Alignment of yyjson_str_pool"][::std::mem::align_of::<yyjson_str_pool>() - 8usize];
    ["Offset of field: yyjson_str_pool::cur"]
        [::std::mem::offset_of!(yyjson_str_pool, cur) - 0usize];
    ["Offset of field: yyjson_str_pool::end"]
        [::std::mem::offset_of!(yyjson_str_pool, end) - 8usize];
    ["Offset of field: yyjson_str_pool::chunk_size"]
        [::std::mem::offset_of!(yyjson_str_pool, chunk_size) - 16usize];
    ["Offset of field: yyjson_str_pool::chunk_size_max"]
        [::std::mem::offset_of!(yyjson_str_pool, chunk_size_max) - 24usize];
    ["Offset of field: yyjson_str_pool::chunks"]
        [::std::mem::offset_of!(yyjson_str_pool, chunks) - 32usize];
};
#[doc = "A memory chunk in value memory pool.\n`sizeof(yyjson_val_chunk)` should not larger than `sizeof(yyjson_mut_val)`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_val_chunk {
    pub next: *mut yyjson_val_chunk,
    pub chunk_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_val_chunk"][::std::mem::size_of::<yyjson_val_chunk>() - 16usize];
    ["Alignment of yyjson_val_chunk"][::std::mem::align_of::<yyjson_val_chunk>() - 8usize];
    ["Offset of field: yyjson_val_chunk::next"]
        [::std::mem::offset_of!(yyjson_val_chunk, next) - 0usize];
    ["Offset of field: yyjson_val_chunk::chunk_size"]
        [::std::mem::offset_of!(yyjson_val_chunk, chunk_size) - 8usize];
};
#[doc = "A memory pool to hold all values in a mutable document."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_val_pool {
    pub cur: *mut yyjson_mut_val,
    pub end: *mut yyjson_mut_val,
    pub chunk_size: usize,
    pub chunk_size_max: usize,
    pub chunks: *mut yyjson_val_chunk,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_val_pool"][::std::mem::size_of::<yyjson_val_pool>() - 40usize];
    ["Alignment of yyjson_val_pool"][::std::mem::align_of::<yyjson_val_pool>() - 8usize];
    ["Offset of field: yyjson_val_pool::cur"]
        [::std::mem::offset_of!(yyjson_val_pool, cur) - 0usize];
    ["Offset of field: yyjson_val_pool::end"]
        [::std::mem::offset_of!(yyjson_val_pool, end) - 8usize];
    ["Offset of field: yyjson_val_pool::chunk_size"]
        [::std::mem::offset_of!(yyjson_val_pool, chunk_size) - 16usize];
    ["Offset of field: yyjson_val_pool::chunk_size_max"]
        [::std::mem::offset_of!(yyjson_val_pool, chunk_size_max) - 24usize];
    ["Offset of field: yyjson_val_pool::chunks"]
        [::std::mem::offset_of!(yyjson_val_pool, chunks) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_mut_doc {
    #[doc = "< root value of the JSON document, nullable"]
    pub root: *mut yyjson_mut_val,
    #[doc = "< a valid allocator, nonnull"]
    pub alc: yyjson_alc,
    #[doc = "< string memory pool"]
    pub str_pool: yyjson_str_pool,
    #[doc = "< value memory pool"]
    pub val_pool: yyjson_val_pool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_mut_doc"][::std::mem::size_of::<yyjson_mut_doc>() - 120usize];
    ["Alignment of yyjson_mut_doc"][::std::mem::align_of::<yyjson_mut_doc>() - 8usize];
    ["Offset of field: yyjson_mut_doc::root"]
        [::std::mem::offset_of!(yyjson_mut_doc, root) - 0usize];
    ["Offset of field: yyjson_mut_doc::alc"][::std::mem::offset_of!(yyjson_mut_doc, alc) - 8usize];
    ["Offset of field: yyjson_mut_doc::str_pool"]
        [::std::mem::offset_of!(yyjson_mut_doc, str_pool) - 40usize];
    ["Offset of field: yyjson_mut_doc::val_pool"]
        [::std::mem::offset_of!(yyjson_mut_doc, val_pool) - 80usize];
};
unsafe extern "C" {
    pub fn unsafe_yyjson_str_pool_grow(
        pool: *mut yyjson_str_pool,
        alc: *const yyjson_alc,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_val_pool_grow(
        pool: *mut yyjson_val_pool,
        alc: *const yyjson_alc,
        count: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_mut_str_alc__extern"]
    pub fn unsafe_yyjson_mut_str_alc(
        doc: *mut yyjson_mut_doc,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_mut_strncpy__extern"]
    pub fn unsafe_yyjson_mut_strncpy(
        doc: *mut yyjson_mut_doc,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_mut_val__extern"]
    pub fn unsafe_yyjson_mut_val(doc: *mut yyjson_mut_doc, count: usize) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_mut_equals(lhs: *mut yyjson_mut_val, rhs: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_mut_obj_add__extern"]
    pub fn unsafe_yyjson_mut_obj_add(
        obj: *mut yyjson_mut_val,
        key: *mut yyjson_mut_val,
        val: *mut yyjson_mut_val,
        len: usize,
    );
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_mut_obj_remove__extern"]
    pub fn unsafe_yyjson_mut_obj_remove(
        obj: *mut yyjson_mut_val,
        key: *const ::std::os::raw::c_char,
        key_len: usize,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_mut_obj_replace__extern"]
    pub fn unsafe_yyjson_mut_obj_replace(
        obj: *mut yyjson_mut_val,
        key: *mut yyjson_mut_val,
        val: *mut yyjson_mut_val,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "unsafe_yyjson_mut_obj_rotate__extern"]
    pub fn unsafe_yyjson_mut_obj_rotate(obj: *mut yyjson_mut_val, idx: usize);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
