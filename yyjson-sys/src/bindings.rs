/* automatically generated by rust-bindgen 0.71.1 */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const YYJSON_MSC_VER: u32 = 0;
pub const YYJSON_IS_REAL_GCC: u32 = 0;
pub const YYJSON_CPP_VER: u32 = 0;
pub const YYJSON_HAS_CONSTANT_P: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const YYJSON_U64_TO_F64_NO_IMPL: u32 = 0;
pub const YYJSON_VERSION_MAJOR: u32 = 0;
pub const YYJSON_VERSION_MINOR: u32 = 10;
pub const YYJSON_VERSION_PATCH: u32 = 0;
pub const YYJSON_VERSION_HEX: u32 = 2560;
pub const YYJSON_VERSION_STRING: &[u8; 7] = b"0.10.0\0";
pub const YYJSON_PADDING_SIZE: u32 = 4;
pub const YYJSON_WRITE_FP_FLAG_BITS: u32 = 8;
pub const YYJSON_WRITE_FP_PREC_BITS: u32 = 4;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq32"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq32) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start32"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start32) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
unsafe extern "C" {
    #[doc = " The version of yyjson in hex, same as `YYJSON_VERSION_HEX`."]
    pub fn yyjson_version() -> u32;
}
#[doc = " Type of a JSON value (3 bit)."]
pub type yyjson_type = u8;
#[doc = " Subtype of a JSON value (2 bit)."]
pub type yyjson_subtype = u8;
#[doc = "A memory allocator.\n\nTypically you don't need to use it, unless you want to customize your own\nmemory allocator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_alc {
    #[doc = " Same as libc's malloc(size), should not be NULL."]
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Same as libc's realloc(ptr, size), should not be NULL."]
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            old_size: usize,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Same as libc's free(ptr), should not be NULL."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, ptr: *mut ::std::os::raw::c_void),
    >,
    #[doc = " A context for malloc/realloc/free, can be NULL."]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_alc"][::std::mem::size_of::<yyjson_alc>() - 32usize];
    ["Alignment of yyjson_alc"][::std::mem::align_of::<yyjson_alc>() - 8usize];
    ["Offset of field: yyjson_alc::malloc"][::std::mem::offset_of!(yyjson_alc, malloc) - 0usize];
    ["Offset of field: yyjson_alc::realloc"][::std::mem::offset_of!(yyjson_alc, realloc) - 8usize];
    ["Offset of field: yyjson_alc::free"][::std::mem::offset_of!(yyjson_alc, free) - 16usize];
    ["Offset of field: yyjson_alc::ctx"][::std::mem::offset_of!(yyjson_alc, ctx) - 24usize];
};
unsafe extern "C" {
    #[doc = "A pool allocator uses fixed length pre-allocated memory.\n\nThis allocator may be used to avoid malloc/realloc calls. The pre-allocated\nmemory should be held by the caller. The maximum amount of memory required to\nread a JSON can be calculated using the `yyjson_read_max_memory_usage()`\nfunction, but the amount of memory required to write a JSON cannot be directly\ncalculated.\n\nThis is not a general-purpose allocator. It is designed to handle a single JSON\ndata at a time. If it is used for overly complex memory tasks, such as parsing\nmultiple JSON documents using the same allocator but releasing only a few of\nthem, it may cause memory fragmentation, resulting in performance degradation\nand memory waste.\n\n@param alc The allocator to be initialized.\nIf this parameter is NULL, the function will fail and return false.\nIf `buf` or `size` is invalid, this will be set to an empty allocator.\n@param buf The buffer memory for this allocator.\nIf this parameter is NULL, the function will fail and return false.\n@param size The size of `buf`, in bytes.\nIf this parameter is less than 8 words (32/64 bytes on 32/64-bit OS), the\nfunction will fail and return false.\n@return true if the `alc` has been successfully initialized.\n\n@par Example\n@code\n// parse JSON with stack memory\nchar buf[1024];\nyyjson_alc alc;\nyyjson_alc_pool_init(&alc, buf, 1024);\n\nconst char *json = \"{\\\"name\\\":\\\"Helvetica\\\",\\\"size\\\":16}\"\nyyjson_doc *doc = yyjson_read_opts(json, strlen(json), 0, &alc, NULL);\n// the memory of `doc` is on the stack\n@endcode\n\n@warning This Allocator is not thread-safe."]
    pub fn yyjson_alc_pool_init(
        alc: *mut yyjson_alc,
        buf: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "A dynamic allocator.\n\nThis allocator has a similar usage to the pool allocator above. However, when\nthere is not enough memory, this allocator will dynamically request more memory\nusing libc's `malloc` function, and frees it all at once when it is destroyed.\n\n@return A new dynamic allocator, or NULL if memory allocation failed.\n@note The returned value should be freed with `yyjson_alc_dyn_free()`.\n\n@warning This Allocator is not thread-safe."]
    pub fn yyjson_alc_dyn_new() -> *mut yyjson_alc;
}
unsafe extern "C" {
    #[doc = "Free a dynamic allocator which is created by `yyjson_alc_dyn_new()`.\n@param alc The dynamic allocator to be destroyed."]
    pub fn yyjson_alc_dyn_free(alc: *mut yyjson_alc);
}
unsafe extern "C" {
    #[doc = "Locate the line and column number for a byte position in a string.\nThis can be used to get better description for error position.\n\n@param str The input string.\n@param len The byte length of the input string.\n@param pos The byte position within the input string.\n@param line A pointer to receive the line number, starting from 1.\n@param col  A pointer to receive the column number, starting from 1.\n@param chr  A pointer to receive the character index, starting from 0.\n@return true on success, false if `str` is NULL or `pos` is out of bounds.\n@note Line/column/character are calculated based on Unicode characters for\ncompatibility with text editors. For multi-byte UTF-8 characters,\nthe returned value may not directly correspond to the byte position."]
    pub fn yyjson_locate_pos(
        str_: *const ::std::os::raw::c_char,
        len: usize,
        pos: usize,
        line: *mut usize,
        col: *mut usize,
        chr: *mut usize,
    ) -> bool;
}
#[doc = " Run-time options for JSON reader."]
pub type yyjson_read_flag = u32;
#[doc = " Default option (RFC 8259 compliant):\n- Read positive integer as uint64_t.\n- Read negative integer as int64_t.\n- Read floating-point number as double with round-to-nearest mode.\n- Read integer which cannot fit in uint64_t or int64_t as double.\n- Report error if double number is infinity.\n- Report error if string contains invalid UTF-8 character or BOM.\n- Report error on trailing commas, comments, inf and nan literals."]
pub const YYJSON_READ_NOFLAG: yyjson_read_flag = 0;
#[doc = " Read the input data in-situ.\nThis option allows the reader to modify and use input data to store string\nvalues, which can increase reading speed slightly.\nThe caller should hold the input data before free the document.\nThe input data must be padded by at least `YYJSON_PADDING_SIZE` bytes.\nFor example: `[1,2]` should be `[1,2]\\0\\0\\0\\0`, input length should be 5."]
pub const YYJSON_READ_INSITU: yyjson_read_flag = 1;
#[doc = " Stop when done instead of issuing an error if there's additional content\nafter a JSON document. This option may be used to parse small pieces of JSON\nin larger data, such as `NDJSON`."]
pub const YYJSON_READ_STOP_WHEN_DONE: yyjson_read_flag = 2;
#[doc = " Allow single trailing comma at the end of an object or array,\nsuch as `[1,2,3,]`, `{\"a\":1,\"b\":2,}` (non-standard)."]
pub const YYJSON_READ_ALLOW_TRAILING_COMMAS: yyjson_read_flag = 4;
#[doc = " Allow C-style single line and multiple line comments (non-standard)."]
pub const YYJSON_READ_ALLOW_COMMENTS: yyjson_read_flag = 8;
#[doc = " Allow inf/nan number and literal, case-insensitive,\nsuch as 1e999, NaN, inf, -Infinity (non-standard)."]
pub const YYJSON_READ_ALLOW_INF_AND_NAN: yyjson_read_flag = 16;
#[doc = " Read all numbers as raw strings (value with `YYJSON_TYPE_RAW` type),\ninf/nan literal is also read as raw with `ALLOW_INF_AND_NAN` flag."]
pub const YYJSON_READ_NUMBER_AS_RAW: yyjson_read_flag = 32;
#[doc = " Allow reading invalid unicode when parsing string values (non-standard).\nInvalid characters will be allowed to appear in the string values, but\ninvalid escape sequences will still be reported as errors.\nThis flag does not affect the performance of correctly encoded strings.\n\n@warning Strings in JSON values may contain incorrect encoding when this\noption is used, you need to handle these strings carefully to avoid security\nrisks."]
pub const YYJSON_READ_ALLOW_INVALID_UNICODE: yyjson_read_flag = 64;
#[doc = " Read big numbers as raw strings. These big numbers include integers that\ncannot be represented by `int64_t` and `uint64_t`, and floating-point\nnumbers that cannot be represented by finite `double`.\nThe flag will be overridden by `YYJSON_READ_NUMBER_AS_RAW` flag."]
pub const YYJSON_READ_BIGNUM_AS_RAW: yyjson_read_flag = 128;
#[doc = " Result code for JSON reader."]
pub type yyjson_read_code = u32;
#[doc = " Success, no error."]
pub const YYJSON_READ_SUCCESS: yyjson_read_code = 0;
#[doc = " Invalid parameter, such as NULL input string or 0 input length."]
pub const YYJSON_READ_ERROR_INVALID_PARAMETER: yyjson_read_code = 1;
#[doc = " Memory allocation failure occurs."]
pub const YYJSON_READ_ERROR_MEMORY_ALLOCATION: yyjson_read_code = 2;
#[doc = " Input JSON string is empty."]
pub const YYJSON_READ_ERROR_EMPTY_CONTENT: yyjson_read_code = 3;
#[doc = " Unexpected content after document, such as `[123]abc`."]
pub const YYJSON_READ_ERROR_UNEXPECTED_CONTENT: yyjson_read_code = 4;
#[doc = " Unexpected ending, such as `[123`."]
pub const YYJSON_READ_ERROR_UNEXPECTED_END: yyjson_read_code = 5;
#[doc = " Unexpected character inside the document, such as `[abc]`."]
pub const YYJSON_READ_ERROR_UNEXPECTED_CHARACTER: yyjson_read_code = 6;
#[doc = " Invalid JSON structure, such as `[1,]`."]
pub const YYJSON_READ_ERROR_JSON_STRUCTURE: yyjson_read_code = 7;
#[doc = " Invalid comment, such as unclosed multi-line comment."]
pub const YYJSON_READ_ERROR_INVALID_COMMENT: yyjson_read_code = 8;
#[doc = " Invalid number, such as `123.e12`, `000`."]
pub const YYJSON_READ_ERROR_INVALID_NUMBER: yyjson_read_code = 9;
#[doc = " Invalid string, such as invalid escaped character inside a string."]
pub const YYJSON_READ_ERROR_INVALID_STRING: yyjson_read_code = 10;
#[doc = " Invalid JSON literal, such as `truu`."]
pub const YYJSON_READ_ERROR_LITERAL: yyjson_read_code = 11;
#[doc = " Failed to open a file."]
pub const YYJSON_READ_ERROR_FILE_OPEN: yyjson_read_code = 12;
#[doc = " Failed to read a file."]
pub const YYJSON_READ_ERROR_FILE_READ: yyjson_read_code = 13;
#[doc = " Error information for JSON reader."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_read_err {
    #[doc = " Error code, see `yyjson_read_code` for all possible values."]
    pub code: yyjson_read_code,
    #[doc = " Error message, constant, no need to free (NULL if success)."]
    pub msg: *const ::std::os::raw::c_char,
    #[doc = " Error byte position for input data (0 if success)."]
    pub pos: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_read_err"][::std::mem::size_of::<yyjson_read_err>() - 24usize];
    ["Alignment of yyjson_read_err"][::std::mem::align_of::<yyjson_read_err>() - 8usize];
    ["Offset of field: yyjson_read_err::code"]
        [::std::mem::offset_of!(yyjson_read_err, code) - 0usize];
    ["Offset of field: yyjson_read_err::msg"]
        [::std::mem::offset_of!(yyjson_read_err, msg) - 8usize];
    ["Offset of field: yyjson_read_err::pos"]
        [::std::mem::offset_of!(yyjson_read_err, pos) - 16usize];
};
unsafe extern "C" {
    #[doc = "Read JSON with options.\n\nThis function is thread-safe when:\n1. The `dat` is not modified by other threads.\n2. The `alc` is thread-safe or NULL.\n\n@param dat The JSON data (UTF-8 without BOM), null-terminator is not required.\nIf this parameter is NULL, the function will fail and return NULL.\nThe `dat` will not be modified without the flag `YYJSON_READ_INSITU`, so you\ncan pass a `const char *` string and case it to `char *` if you don't use\nthe `YYJSON_READ_INSITU` flag.\n@param len The length of JSON data in bytes.\nIf this parameter is 0, the function will fail and return NULL.\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON reader.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON document, or NULL if an error occurs.\nWhen it's no longer needed, it should be freed with `yyjson_doc_free()`."]
    pub fn yyjson_read_opts(
        dat: *mut ::std::os::raw::c_char,
        len: usize,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = "Read a JSON file.\n\nThis function is thread-safe when:\n1. The file is not modified by other threads.\n2. The `alc` is thread-safe or NULL.\n\n@param path The JSON file's path.\nIf this path is NULL or invalid, the function will fail and return NULL.\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON reader.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON document, or NULL if an error occurs.\nWhen it's no longer needed, it should be freed with `yyjson_doc_free()`.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to read."]
    pub fn yyjson_read_file(
        path: *const ::std::os::raw::c_char,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = "Read JSON from a file pointer.\n\n@param fp The file pointer.\nThe data will be read from the current position of the FILE to the end.\nIf this fp is NULL or invalid, the function will fail and return NULL.\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON reader.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON document, or NULL if an error occurs.\nWhen it's no longer needed, it should be freed with `yyjson_doc_free()`.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to read."]
    pub fn yyjson_read_fp(
        fp: *mut FILE,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = "Read a JSON number.\n\nThis function is thread-safe when data is not modified by other threads.\n\n@param dat The JSON data (UTF-8 without BOM), null-terminator is required.\nIf this parameter is NULL, the function will fail and return NULL.\n@param val The output value where result is stored.\nIf this parameter is NULL, the function will fail and return NULL.\nThe value will hold either UINT or SINT or REAL number;\n@param flg The JSON read options.\nMultiple options can be combined with `|` operator. 0 means no options.\nSupports `YYJSON_READ_NUMBER_AS_RAW` and `YYJSON_READ_ALLOW_INF_AND_NAN`.\n@param alc The memory allocator used for long number.\nIt is only used when the built-in floating point reader is disabled.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return If successful, a pointer to the character after the last character\nused in the conversion, NULL if an error occurs."]
    pub fn yyjson_read_number(
        dat: *const ::std::os::raw::c_char,
        val: *mut yyjson_val,
        flg: yyjson_read_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_read_err,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " Run-time options for JSON writer."]
pub type yyjson_write_flag = u32;
#[doc = " Default option:\n- Write JSON minify.\n- Report error on inf or nan number.\n- Report error on invalid UTF-8 string.\n- Do not escape unicode or slash."]
pub const YYJSON_WRITE_NOFLAG: yyjson_write_flag = 0;
#[doc = " Write JSON pretty with 4 space indent."]
pub const YYJSON_WRITE_PRETTY: yyjson_write_flag = 1;
#[doc = " Escape unicode as `uXXXX`, make the output ASCII only."]
pub const YYJSON_WRITE_ESCAPE_UNICODE: yyjson_write_flag = 2;
#[doc = " Escape '/' as '\\/'."]
pub const YYJSON_WRITE_ESCAPE_SLASHES: yyjson_write_flag = 4;
#[doc = " Write inf and nan number as 'Infinity' and 'NaN' literal (non-standard)."]
pub const YYJSON_WRITE_ALLOW_INF_AND_NAN: yyjson_write_flag = 8;
#[doc = " Write inf and nan number as null literal.\nThis flag will override `YYJSON_WRITE_ALLOW_INF_AND_NAN` flag."]
pub const YYJSON_WRITE_INF_AND_NAN_AS_NULL: yyjson_write_flag = 16;
#[doc = " Allow invalid unicode when encoding string values (non-standard).\nInvalid characters in string value will be copied byte by byte.\nIf `YYJSON_WRITE_ESCAPE_UNICODE` flag is also set, invalid character will be\nescaped as `U+FFFD` (replacement character).\nThis flag does not affect the performance of correctly encoded strings."]
pub const YYJSON_WRITE_ALLOW_INVALID_UNICODE: yyjson_write_flag = 32;
#[doc = " Write JSON pretty with 2 space indent.\nThis flag will override `YYJSON_WRITE_PRETTY` flag."]
pub const YYJSON_WRITE_PRETTY_TWO_SPACES: yyjson_write_flag = 64;
#[doc = " Adds a newline character `\\n` at the end of the JSON.\nThis can be helpful for text editors or NDJSON."]
pub const YYJSON_WRITE_NEWLINE_AT_END: yyjson_write_flag = 128;
#[doc = " Result code for JSON writer"]
pub type yyjson_write_code = u32;
#[doc = " Success, no error."]
pub const YYJSON_WRITE_SUCCESS: yyjson_write_code = 0;
#[doc = " Invalid parameter, such as NULL document."]
pub const YYJSON_WRITE_ERROR_INVALID_PARAMETER: yyjson_write_code = 1;
#[doc = " Memory allocation failure occurs."]
pub const YYJSON_WRITE_ERROR_MEMORY_ALLOCATION: yyjson_write_code = 2;
#[doc = " Invalid value type in JSON document."]
pub const YYJSON_WRITE_ERROR_INVALID_VALUE_TYPE: yyjson_write_code = 3;
#[doc = " NaN or Infinity number occurs."]
pub const YYJSON_WRITE_ERROR_NAN_OR_INF: yyjson_write_code = 4;
#[doc = " Failed to open a file."]
pub const YYJSON_WRITE_ERROR_FILE_OPEN: yyjson_write_code = 5;
#[doc = " Failed to write a file."]
pub const YYJSON_WRITE_ERROR_FILE_WRITE: yyjson_write_code = 6;
#[doc = " Invalid unicode in string."]
pub const YYJSON_WRITE_ERROR_INVALID_STRING: yyjson_write_code = 7;
#[doc = " Error information for JSON writer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_write_err {
    #[doc = " Error code, see `yyjson_write_code` for all possible values."]
    pub code: yyjson_write_code,
    #[doc = " Error message, constant, no need to free (NULL if success)."]
    pub msg: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_write_err"][::std::mem::size_of::<yyjson_write_err>() - 16usize];
    ["Alignment of yyjson_write_err"][::std::mem::align_of::<yyjson_write_err>() - 8usize];
    ["Offset of field: yyjson_write_err::code"]
        [::std::mem::offset_of!(yyjson_write_err, code) - 0usize];
    ["Offset of field: yyjson_write_err::msg"]
        [::std::mem::offset_of!(yyjson_write_err, msg) - 8usize];
};
unsafe extern "C" {
    #[doc = "Write a document to JSON string with options.\n\nThis function is thread-safe when:\nThe `alc` is thread-safe or NULL.\n\n@param doc The JSON document.\nIf this doc is NULL or has no root, the function will fail and return false.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param len A pointer to receive output length in bytes (not including the\nnull-terminator). Pass NULL if you don't need length information.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON string, or NULL if an error occurs.\nThis string is encoded as UTF-8 with a null-terminator.\nWhen it's no longer needed, it should be freed with free() or alc->free()."]
    pub fn yyjson_write_opts(
        doc: *const yyjson_doc,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        len: *mut usize,
        err: *mut yyjson_write_err,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Write a document to JSON file with options.\n\nThis function is thread-safe when:\n1. The file is not accessed by other threads.\n2. The `alc` is thread-safe or NULL.\n\n@param path The JSON file's path.\nIf this path is NULL or invalid, the function will fail and return false.\nIf this file is not empty, the content will be discarded.\n@param doc The JSON document.\nIf this doc is NULL or has no root, the function will fail and return false.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return true if successful, false if an error occurs.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to write."]
    pub fn yyjson_write_file(
        path: *const ::std::os::raw::c_char,
        doc: *const yyjson_doc,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_write_err,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write a document to file pointer with options.\n\n@param fp The file pointer.\nThe data will be written to the current position of the file.\nIf this fp is NULL or invalid, the function will fail and return false.\n@param doc The JSON document.\nIf this doc is NULL or has no root, the function will fail and return false.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return true if successful, false if an error occurs.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to write."]
    pub fn yyjson_write_fp(
        fp: *mut FILE,
        doc: *const yyjson_doc,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_write_err,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write a document to JSON string with options.\n\nThis function is thread-safe when:\n1. The `doc` is not modified by other threads.\n2. The `alc` is thread-safe or NULL.\n\n@param doc The mutable JSON document.\nIf this doc is NULL or has no root, the function will fail and return false.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param len A pointer to receive output length in bytes (not including the\nnull-terminator). Pass NULL if you don't need length information.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON string, or NULL if an error occurs.\nThis string is encoded as UTF-8 with a null-terminator.\nWhen it's no longer needed, it should be freed with free() or alc->free()."]
    pub fn yyjson_mut_write_opts(
        doc: *const yyjson_mut_doc,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        len: *mut usize,
        err: *mut yyjson_write_err,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Write a document to JSON file with options.\n\nThis function is thread-safe when:\n1. The file is not accessed by other threads.\n2. The `doc` is not modified by other threads.\n3. The `alc` is thread-safe or NULL.\n\n@param path The JSON file's path.\nIf this path is NULL or invalid, the function will fail and return false.\nIf this file is not empty, the content will be discarded.\n@param doc The mutable JSON document.\nIf this doc is NULL or has no root, the function will fail and return false.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return true if successful, false if an error occurs.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to write."]
    pub fn yyjson_mut_write_file(
        path: *const ::std::os::raw::c_char,
        doc: *const yyjson_mut_doc,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_write_err,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write a document to file pointer with options.\n\n@param fp The file pointer.\nThe data will be written to the current position of the file.\nIf this fp is NULL or invalid, the function will fail and return false.\n@param doc The mutable JSON document.\nIf this doc is NULL or has no root, the function will fail and return false.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return true if successful, false if an error occurs.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to write."]
    pub fn yyjson_mut_write_fp(
        fp: *mut FILE,
        doc: *const yyjson_mut_doc,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_write_err,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write a value to JSON string with options.\n\nThis function is thread-safe when:\nThe `alc` is thread-safe or NULL.\n\n@param val The JSON root value.\nIf this parameter is NULL, the function will fail and return NULL.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param len A pointer to receive output length in bytes (not including the\nnull-terminator). Pass NULL if you don't need length information.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return A new JSON string, or NULL if an error occurs.\nThis string is encoded as UTF-8 with a null-terminator.\nWhen it's no longer needed, it should be freed with free() or alc->free()."]
    pub fn yyjson_val_write_opts(
        val: *const yyjson_val,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        len: *mut usize,
        err: *mut yyjson_write_err,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Write a value to JSON file with options.\n\nThis function is thread-safe when:\n1. The file is not accessed by other threads.\n2. The `alc` is thread-safe or NULL.\n\n@param path The JSON file's path.\nIf this path is NULL or invalid, the function will fail and return false.\nIf this file is not empty, the content will be discarded.\n@param val The JSON root value.\nIf this parameter is NULL, the function will fail and return NULL.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return true if successful, false if an error occurs.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to write."]
    pub fn yyjson_val_write_file(
        path: *const ::std::os::raw::c_char,
        val: *const yyjson_val,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_write_err,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write a value to file pointer with options.\n\n@param fp The file pointer.\nThe data will be written to the current position of the file.\nIf this path is NULL or invalid, the function will fail and return false.\n@param val The JSON root value.\nIf this parameter is NULL, the function will fail and return NULL.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return true if successful, false if an error occurs.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to write."]
    pub fn yyjson_val_write_fp(
        fp: *mut FILE,
        val: *const yyjson_val,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_write_err,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write a value to JSON string with options.\n\nThis function is thread-safe when:\n1. The `val` is not modified by other threads.\n2. The `alc` is thread-safe or NULL.\n\n@param val The mutable JSON root value.\nIf this parameter is NULL, the function will fail and return NULL.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param len A pointer to receive output length in bytes (not including the\nnull-terminator). Pass NULL if you don't need length information.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return  A new JSON string, or NULL if an error occurs.\nThis string is encoded as UTF-8 with a null-terminator.\nWhen it's no longer needed, it should be freed with free() or alc->free()."]
    pub fn yyjson_mut_val_write_opts(
        val: *const yyjson_mut_val,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        len: *mut usize,
        err: *mut yyjson_write_err,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Write a value to JSON file with options.\n\nThis function is thread-safe when:\n1. The file is not accessed by other threads.\n2. The `val` is not modified by other threads.\n3. The `alc` is thread-safe or NULL.\n\n@param path The JSON file's path.\nIf this path is NULL or invalid, the function will fail and return false.\nIf this file is not empty, the content will be discarded.\n@param val The mutable JSON root value.\nIf this parameter is NULL, the function will fail and return NULL.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return true if successful, false if an error occurs.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to write."]
    pub fn yyjson_mut_val_write_file(
        path: *const ::std::os::raw::c_char,
        val: *const yyjson_mut_val,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_write_err,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write a value to JSON file with options.\n\n@param fp The file pointer.\nThe data will be written to the current position of the file.\nIf this path is NULL or invalid, the function will fail and return false.\n@param val The mutable JSON root value.\nIf this parameter is NULL, the function will fail and return NULL.\n@param flg The JSON write options.\nMultiple options can be combined with `|` operator. 0 means no options.\n@param alc The memory allocator used by JSON writer.\nPass NULL to use the libc's default allocator.\n@param err A pointer to receive error information.\nPass NULL if you don't need error information.\n@return true if successful, false if an error occurs.\n\n@warning On 32-bit operating system, files larger than 2GB may fail to write."]
    pub fn yyjson_mut_val_write_fp(
        fp: *mut FILE,
        val: *const yyjson_mut_val,
        flg: yyjson_write_flag,
        alc: *const yyjson_alc,
        err: *mut yyjson_write_err,
    ) -> bool;
}
#[doc = "A JSON array iterator.\n\n@par Example\n@code\nyyjson_val *val;\nyyjson_arr_iter iter = yyjson_arr_iter_with(arr);\nwhile ((val = yyjson_arr_iter_next(&iter))) {\nyour_func(val);\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_arr_iter {
    #[doc = "< next value's index"]
    pub idx: usize,
    #[doc = "< maximum index (arr.size)"]
    pub max: usize,
    #[doc = "< next value"]
    pub cur: *mut yyjson_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_arr_iter"][::std::mem::size_of::<yyjson_arr_iter>() - 24usize];
    ["Alignment of yyjson_arr_iter"][::std::mem::align_of::<yyjson_arr_iter>() - 8usize];
    ["Offset of field: yyjson_arr_iter::idx"]
        [::std::mem::offset_of!(yyjson_arr_iter, idx) - 0usize];
    ["Offset of field: yyjson_arr_iter::max"]
        [::std::mem::offset_of!(yyjson_arr_iter, max) - 8usize];
    ["Offset of field: yyjson_arr_iter::cur"]
        [::std::mem::offset_of!(yyjson_arr_iter, cur) - 16usize];
};
#[doc = "A JSON object iterator.\n\n@par Example\n@code\nyyjson_val *key, *val;\nyyjson_obj_iter iter = yyjson_obj_iter_with(obj);\nwhile ((key = yyjson_obj_iter_next(&iter))) {\nval = yyjson_obj_iter_get_val(key);\nyour_func(key, val);\n}\n@endcode\n\nIf the ordering of the keys is known at compile-time, you can use this method\nto speed up value lookups:\n@code\n// {\"k1\":1, \"k2\": 3, \"k3\": 3}\nyyjson_val *key, *val;\nyyjson_obj_iter iter = yyjson_obj_iter_with(obj);\nyyjson_val *v1 = yyjson_obj_iter_get(&iter, \"k1\");\nyyjson_val *v3 = yyjson_obj_iter_get(&iter, \"k3\");\n@endcode\n@see yyjson_obj_iter_get() and yyjson_obj_iter_getn()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_obj_iter {
    #[doc = "< next key's index"]
    pub idx: usize,
    #[doc = "< maximum key index (obj.size)"]
    pub max: usize,
    #[doc = "< next key"]
    pub cur: *mut yyjson_val,
    #[doc = "< the object being iterated"]
    pub obj: *mut yyjson_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_obj_iter"][::std::mem::size_of::<yyjson_obj_iter>() - 32usize];
    ["Alignment of yyjson_obj_iter"][::std::mem::align_of::<yyjson_obj_iter>() - 8usize];
    ["Offset of field: yyjson_obj_iter::idx"]
        [::std::mem::offset_of!(yyjson_obj_iter, idx) - 0usize];
    ["Offset of field: yyjson_obj_iter::max"]
        [::std::mem::offset_of!(yyjson_obj_iter, max) - 8usize];
    ["Offset of field: yyjson_obj_iter::cur"]
        [::std::mem::offset_of!(yyjson_obj_iter, cur) - 16usize];
    ["Offset of field: yyjson_obj_iter::obj"]
        [::std::mem::offset_of!(yyjson_obj_iter, obj) - 24usize];
};
unsafe extern "C" {
    #[doc = "Set the string pool size for a mutable document.\nThis function does not allocate memory immediately, but uses the size when\nthe next memory allocation is needed.\n\nIf the caller knows the approximate bytes of strings that the document needs to\nstore (e.g. copy string with `yyjson_mut_strcpy` function), setting a larger\nsize can avoid multiple memory allocations and improve performance.\n\n@param doc The mutable document.\n@param len The desired string pool size in bytes (total string length).\n@return true if successful, false if size is 0 or overflow."]
    pub fn yyjson_mut_doc_set_str_pool_size(doc: *mut yyjson_mut_doc, len: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the value pool size for a mutable document.\nThis function does not allocate memory immediately, but uses the size when\nthe next memory allocation is needed.\n\nIf the caller knows the approximate number of values that the document needs to\nstore (e.g. create new value with `yyjson_mut_xxx` functions), setting a larger\nsize can avoid multiple memory allocations and improve performance.\n\n@param doc The mutable document.\n@param count The desired value pool size (number of `yyjson_mut_val`).\n@return true if successful, false if size is 0 or overflow."]
    pub fn yyjson_mut_doc_set_val_pool_size(doc: *mut yyjson_mut_doc, count: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Release the JSON document and free the memory.\nAfter calling this function, the `doc` and all values from the `doc` are no\nlonger available. This function will do nothing if the `doc` is NULL."]
    pub fn yyjson_mut_doc_free(doc: *mut yyjson_mut_doc);
}
unsafe extern "C" {
    #[doc = " Creates and returns a new mutable JSON document, returns NULL on error.\nIf allocator is NULL, the default allocator will be used."]
    pub fn yyjson_mut_doc_new(alc: *const yyjson_alc) -> *mut yyjson_mut_doc;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new mutable document from input, returns NULL on error.\nThis makes a `deep-copy` on the immutable document.\nIf allocator is NULL, the default allocator will be used.\n@note `imut_doc` -> `mut_doc`."]
    pub fn yyjson_doc_mut_copy(doc: *mut yyjson_doc, alc: *const yyjson_alc)
        -> *mut yyjson_mut_doc;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new mutable document from input, returns NULL on error.\nThis makes a `deep-copy` on the mutable document.\nIf allocator is NULL, the default allocator will be used.\n@note `mut_doc` -> `mut_doc`."]
    pub fn yyjson_mut_doc_mut_copy(
        doc: *mut yyjson_mut_doc,
        alc: *const yyjson_alc,
    ) -> *mut yyjson_mut_doc;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new mutable value from input, returns NULL on error.\nThis makes a `deep-copy` on the immutable value.\nThe memory was managed by mutable document.\n@note `imut_val` -> `mut_val`."]
    pub fn yyjson_val_mut_copy(
        doc: *mut yyjson_mut_doc,
        val: *mut yyjson_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new mutable value from input, returns NULL on error.\nThis makes a `deep-copy` on the mutable value.\nThe memory was managed by mutable document.\n@note `mut_val` -> `mut_val`.\n@warning This function is recursive and may cause a stack overflow\nif the object level is too deep."]
    pub fn yyjson_mut_val_mut_copy(
        doc: *mut yyjson_mut_doc,
        val: *mut yyjson_mut_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new immutable document from input,\nreturns NULL on error. This makes a `deep-copy` on the mutable document.\nThe returned document should be freed with `yyjson_doc_free()`.\n@note `mut_doc` -> `imut_doc`.\n@warning This function is recursive and may cause a stack overflow\nif the object level is too deep."]
    pub fn yyjson_mut_doc_imut_copy(
        doc: *mut yyjson_mut_doc,
        alc: *const yyjson_alc,
    ) -> *mut yyjson_doc;
}
unsafe extern "C" {
    #[doc = " Copies and returns a new immutable document from input,\nreturns NULL on error. This makes a `deep-copy` on the mutable value.\nThe returned document should be freed with `yyjson_doc_free()`.\n@note `mut_val` -> `imut_doc`.\n@warning This function is recursive and may cause a stack overflow\nif the object level is too deep."]
    pub fn yyjson_mut_val_imut_copy(
        val: *mut yyjson_mut_val,
        alc: *const yyjson_alc,
    ) -> *mut yyjson_doc;
}
#[doc = "A mutable JSON array iterator.\n\n@warning You should not modify the array while iterating over it, but you can\nuse `yyjson_mut_arr_iter_remove()` to remove current value.\n\n@par Example\n@code\nyyjson_mut_val *val;\nyyjson_mut_arr_iter iter = yyjson_mut_arr_iter_with(arr);\nwhile ((val = yyjson_mut_arr_iter_next(&iter))) {\nyour_func(val);\nif (your_val_is_unused(val)) {\nyyjson_mut_arr_iter_remove(&iter);\n}\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_mut_arr_iter {
    #[doc = "< next value's index"]
    pub idx: usize,
    #[doc = "< maximum index (arr.size)"]
    pub max: usize,
    #[doc = "< current value"]
    pub cur: *mut yyjson_mut_val,
    #[doc = "< previous value"]
    pub pre: *mut yyjson_mut_val,
    #[doc = "< the array being iterated"]
    pub arr: *mut yyjson_mut_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_mut_arr_iter"][::std::mem::size_of::<yyjson_mut_arr_iter>() - 40usize];
    ["Alignment of yyjson_mut_arr_iter"][::std::mem::align_of::<yyjson_mut_arr_iter>() - 8usize];
    ["Offset of field: yyjson_mut_arr_iter::idx"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, idx) - 0usize];
    ["Offset of field: yyjson_mut_arr_iter::max"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, max) - 8usize];
    ["Offset of field: yyjson_mut_arr_iter::cur"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, cur) - 16usize];
    ["Offset of field: yyjson_mut_arr_iter::pre"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, pre) - 24usize];
    ["Offset of field: yyjson_mut_arr_iter::arr"]
        [::std::mem::offset_of!(yyjson_mut_arr_iter, arr) - 32usize];
};
#[doc = "A mutable JSON object iterator.\n\n@warning You should not modify the object while iterating over it, but you can\nuse `yyjson_mut_obj_iter_remove()` to remove current value.\n\n@par Example\n@code\nyyjson_mut_val *key, *val;\nyyjson_mut_obj_iter iter = yyjson_mut_obj_iter_with(obj);\nwhile ((key = yyjson_mut_obj_iter_next(&iter))) {\nval = yyjson_mut_obj_iter_get_val(key);\nyour_func(key, val);\nif (your_val_is_unused(key, val)) {\nyyjson_mut_obj_iter_remove(&iter);\n}\n}\n@endcode\n\nIf the ordering of the keys is known at compile-time, you can use this method\nto speed up value lookups:\n@code\n// {\"k1\":1, \"k2\": 3, \"k3\": 3}\nyyjson_mut_val *key, *val;\nyyjson_mut_obj_iter iter = yyjson_mut_obj_iter_with(obj);\nyyjson_mut_val *v1 = yyjson_mut_obj_iter_get(&iter, \"k1\");\nyyjson_mut_val *v3 = yyjson_mut_obj_iter_get(&iter, \"k3\");\n@endcode\n@see `yyjson_mut_obj_iter_get()` and `yyjson_mut_obj_iter_getn()`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_mut_obj_iter {
    #[doc = "< next key's index"]
    pub idx: usize,
    #[doc = "< maximum key index (obj.size)"]
    pub max: usize,
    #[doc = "< current key"]
    pub cur: *mut yyjson_mut_val,
    #[doc = "< previous key"]
    pub pre: *mut yyjson_mut_val,
    #[doc = "< the object being iterated"]
    pub obj: *mut yyjson_mut_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_mut_obj_iter"][::std::mem::size_of::<yyjson_mut_obj_iter>() - 40usize];
    ["Alignment of yyjson_mut_obj_iter"][::std::mem::align_of::<yyjson_mut_obj_iter>() - 8usize];
    ["Offset of field: yyjson_mut_obj_iter::idx"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, idx) - 0usize];
    ["Offset of field: yyjson_mut_obj_iter::max"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, max) - 8usize];
    ["Offset of field: yyjson_mut_obj_iter::cur"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, cur) - 16usize];
    ["Offset of field: yyjson_mut_obj_iter::pre"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, pre) - 24usize];
    ["Offset of field: yyjson_mut_obj_iter::obj"]
        [::std::mem::offset_of!(yyjson_mut_obj_iter, obj) - 32usize];
};
#[doc = " JSON Pointer error code."]
pub type yyjson_ptr_code = u32;
#[doc = " No JSON pointer error."]
pub const YYJSON_PTR_ERR_NONE: yyjson_ptr_code = 0;
#[doc = " Invalid input parameter, such as NULL input."]
pub const YYJSON_PTR_ERR_PARAMETER: yyjson_ptr_code = 1;
#[doc = " JSON pointer syntax error, such as invalid escape, token no prefix."]
pub const YYJSON_PTR_ERR_SYNTAX: yyjson_ptr_code = 2;
#[doc = " JSON pointer resolve failed, such as index out of range, key not found."]
pub const YYJSON_PTR_ERR_RESOLVE: yyjson_ptr_code = 3;
#[doc = " Document's root is NULL, but it is required for the function call."]
pub const YYJSON_PTR_ERR_NULL_ROOT: yyjson_ptr_code = 4;
#[doc = " Cannot set root as the target is not a document."]
pub const YYJSON_PTR_ERR_SET_ROOT: yyjson_ptr_code = 5;
#[doc = " The memory allocation failed and a new value could not be created."]
pub const YYJSON_PTR_ERR_MEMORY_ALLOCATION: yyjson_ptr_code = 6;
#[doc = " Error information for JSON pointer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_ptr_err {
    #[doc = " Error code, see `yyjson_ptr_code` for all possible values."]
    pub code: yyjson_ptr_code,
    #[doc = " Error message, constant, no need to free (NULL if no error)."]
    pub msg: *const ::std::os::raw::c_char,
    #[doc = " Error byte position for input JSON pointer (0 if no error)."]
    pub pos: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_ptr_err"][::std::mem::size_of::<yyjson_ptr_err>() - 24usize];
    ["Alignment of yyjson_ptr_err"][::std::mem::align_of::<yyjson_ptr_err>() - 8usize];
    ["Offset of field: yyjson_ptr_err::code"]
        [::std::mem::offset_of!(yyjson_ptr_err, code) - 0usize];
    ["Offset of field: yyjson_ptr_err::msg"][::std::mem::offset_of!(yyjson_ptr_err, msg) - 8usize];
    ["Offset of field: yyjson_ptr_err::pos"][::std::mem::offset_of!(yyjson_ptr_err, pos) - 16usize];
};
#[doc = "A context for JSON pointer operation.\n\nThis struct stores the context of JSON Pointer operation result. The struct\ncan be used with three helper functions: `ctx_append()`, `ctx_replace()`, and\n`ctx_remove()`, which perform the corresponding operations on the container\nwithout re-parsing the JSON Pointer.\n\nFor example:\n@code\n// doc before: {\"a\":[0,1,null]}\n// ptr: \"/a/2\"\nval = yyjson_mut_doc_ptr_getx(doc, ptr, strlen(ptr), &ctx, &err);\nif (yyjson_is_null(val)) {\nyyjson_ptr_ctx_remove(&ctx);\n}\n// doc after: {\"a\":[0,1]}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_ptr_ctx {
    #[doc = "The container (parent) of the target value. It can be either an array or\nan object. If the target location has no value, but all its parent\ncontainers exist, and the target location can be used to insert a new\nvalue, then `ctn` is the parent container of the target location.\nOtherwise, `ctn` is NULL."]
    pub ctn: *mut yyjson_mut_val,
    #[doc = "The previous sibling of the target value. It can be either a value in an\narray or a key in an object. As the container is a `circular linked list`\nof elements, `pre` is the previous node of the target value. If the\noperation is `add` or `set`, then `pre` is the previous node of the new\nvalue, not the original target value. If the target value does not exist,\n`pre` is NULL."]
    pub pre: *mut yyjson_mut_val,
    #[doc = "The removed value if the operation is `set`, `replace` or `remove`. It can\nbe used to restore the original state of the document if needed."]
    pub old: *mut yyjson_mut_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_ptr_ctx"][::std::mem::size_of::<yyjson_ptr_ctx>() - 24usize];
    ["Alignment of yyjson_ptr_ctx"][::std::mem::align_of::<yyjson_ptr_ctx>() - 8usize];
    ["Offset of field: yyjson_ptr_ctx::ctn"][::std::mem::offset_of!(yyjson_ptr_ctx, ctn) - 0usize];
    ["Offset of field: yyjson_ptr_ctx::pre"][::std::mem::offset_of!(yyjson_ptr_ctx, pre) - 8usize];
    ["Offset of field: yyjson_ptr_ctx::old"][::std::mem::offset_of!(yyjson_ptr_ctx, old) - 16usize];
};
#[doc = " Result code for JSON patch."]
pub type yyjson_patch_code = u32;
#[doc = " Success, no error."]
pub const YYJSON_PATCH_SUCCESS: yyjson_patch_code = 0;
#[doc = " Invalid parameter, such as NULL input or non-array patch."]
pub const YYJSON_PATCH_ERROR_INVALID_PARAMETER: yyjson_patch_code = 1;
#[doc = " Memory allocation failure occurs."]
pub const YYJSON_PATCH_ERROR_MEMORY_ALLOCATION: yyjson_patch_code = 2;
#[doc = " JSON patch operation is not object type."]
pub const YYJSON_PATCH_ERROR_INVALID_OPERATION: yyjson_patch_code = 3;
#[doc = " JSON patch operation is missing a required key."]
pub const YYJSON_PATCH_ERROR_MISSING_KEY: yyjson_patch_code = 4;
#[doc = " JSON patch operation member is invalid."]
pub const YYJSON_PATCH_ERROR_INVALID_MEMBER: yyjson_patch_code = 5;
#[doc = " JSON patch operation `test` not equal."]
pub const YYJSON_PATCH_ERROR_EQUAL: yyjson_patch_code = 6;
#[doc = " JSON patch operation failed on JSON pointer."]
pub const YYJSON_PATCH_ERROR_POINTER: yyjson_patch_code = 7;
#[doc = " Error information for JSON patch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_patch_err {
    #[doc = " Error code, see `yyjson_patch_code` for all possible values."]
    pub code: yyjson_patch_code,
    #[doc = " Index of the error operation (0 if no error)."]
    pub idx: usize,
    #[doc = " Error message, constant, no need to free (NULL if no error)."]
    pub msg: *const ::std::os::raw::c_char,
    #[doc = " JSON pointer error if `code == YYJSON_PATCH_ERROR_POINTER`."]
    pub ptr: yyjson_ptr_err,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_patch_err"][::std::mem::size_of::<yyjson_patch_err>() - 48usize];
    ["Alignment of yyjson_patch_err"][::std::mem::align_of::<yyjson_patch_err>() - 8usize];
    ["Offset of field: yyjson_patch_err::code"]
        [::std::mem::offset_of!(yyjson_patch_err, code) - 0usize];
    ["Offset of field: yyjson_patch_err::idx"]
        [::std::mem::offset_of!(yyjson_patch_err, idx) - 8usize];
    ["Offset of field: yyjson_patch_err::msg"]
        [::std::mem::offset_of!(yyjson_patch_err, msg) - 16usize];
    ["Offset of field: yyjson_patch_err::ptr"]
        [::std::mem::offset_of!(yyjson_patch_err, ptr) - 24usize];
};
unsafe extern "C" {
    #[doc = "Creates and returns a patched JSON value (RFC 6902).\nThe memory of the returned value is allocated by the `doc`.\nThe `err` is used to receive error information, pass NULL if not needed.\nReturns NULL if the patch could not be applied."]
    pub fn yyjson_patch(
        doc: *mut yyjson_mut_doc,
        orig: *mut yyjson_val,
        patch: *mut yyjson_val,
        err: *mut yyjson_patch_err,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a patched JSON value (RFC 6902).\nThe memory of the returned value is allocated by the `doc`.\nThe `err` is used to receive error information, pass NULL if not needed.\nReturns NULL if the patch could not be applied."]
    pub fn yyjson_mut_patch(
        doc: *mut yyjson_mut_doc,
        orig: *mut yyjson_mut_val,
        patch: *mut yyjson_mut_val,
        err: *mut yyjson_patch_err,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a merge-patched JSON value (RFC 7386).\nThe memory of the returned value is allocated by the `doc`.\nReturns NULL if the patch could not be applied.\n\n@warning This function is recursive and may cause a stack overflow if the\nobject level is too deep."]
    pub fn yyjson_merge_patch(
        doc: *mut yyjson_mut_doc,
        orig: *mut yyjson_val,
        patch: *mut yyjson_val,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    #[doc = "Creates and returns a merge-patched JSON value (RFC 7386).\nThe memory of the returned value is allocated by the `doc`.\nReturns NULL if the patch could not be applied.\n\n@warning This function is recursive and may cause a stack overflow if the\nobject level is too deep."]
    pub fn yyjson_mut_merge_patch(
        doc: *mut yyjson_mut_doc,
        orig: *mut yyjson_mut_val,
        patch: *mut yyjson_mut_val,
    ) -> *mut yyjson_mut_val;
}
#[doc = " Payload of a JSON value (8 bytes)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union yyjson_val_uni {
    pub u64_: u64,
    pub i64_: i64,
    pub f64_: f64,
    pub str_: *const ::std::os::raw::c_char,
    pub ptr: *mut ::std::os::raw::c_void,
    pub ofs: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_val_uni"][::std::mem::size_of::<yyjson_val_uni>() - 8usize];
    ["Alignment of yyjson_val_uni"][::std::mem::align_of::<yyjson_val_uni>() - 8usize];
    ["Offset of field: yyjson_val_uni::u64_"]
        [::std::mem::offset_of!(yyjson_val_uni, u64_) - 0usize];
    ["Offset of field: yyjson_val_uni::i64_"]
        [::std::mem::offset_of!(yyjson_val_uni, i64_) - 0usize];
    ["Offset of field: yyjson_val_uni::f64_"]
        [::std::mem::offset_of!(yyjson_val_uni, f64_) - 0usize];
    ["Offset of field: yyjson_val_uni::str_"]
        [::std::mem::offset_of!(yyjson_val_uni, str_) - 0usize];
    ["Offset of field: yyjson_val_uni::ptr"][::std::mem::offset_of!(yyjson_val_uni, ptr) - 0usize];
    ["Offset of field: yyjson_val_uni::ofs"][::std::mem::offset_of!(yyjson_val_uni, ofs) - 0usize];
};
#[doc = "Immutable JSON value, 16 bytes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct yyjson_val {
    #[doc = "< type, subtype and length"]
    pub tag: u64,
    #[doc = "< payload"]
    pub uni: yyjson_val_uni,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_val"][::std::mem::size_of::<yyjson_val>() - 16usize];
    ["Alignment of yyjson_val"][::std::mem::align_of::<yyjson_val>() - 8usize];
    ["Offset of field: yyjson_val::tag"][::std::mem::offset_of!(yyjson_val, tag) - 0usize];
    ["Offset of field: yyjson_val::uni"][::std::mem::offset_of!(yyjson_val, uni) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_doc {
    #[doc = " Root value of the document (nonnull)."]
    pub root: *mut yyjson_val,
    #[doc = " Allocator used by document (nonnull)."]
    pub alc: yyjson_alc,
    #[doc = " The total number of bytes read when parsing JSON (nonzero)."]
    pub dat_read: usize,
    #[doc = " The total number of value read when parsing JSON (nonzero)."]
    pub val_read: usize,
    #[doc = " The string pool used by JSON values (nullable)."]
    pub str_pool: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_doc"][::std::mem::size_of::<yyjson_doc>() - 64usize];
    ["Alignment of yyjson_doc"][::std::mem::align_of::<yyjson_doc>() - 8usize];
    ["Offset of field: yyjson_doc::root"][::std::mem::offset_of!(yyjson_doc, root) - 0usize];
    ["Offset of field: yyjson_doc::alc"][::std::mem::offset_of!(yyjson_doc, alc) - 8usize];
    ["Offset of field: yyjson_doc::dat_read"]
        [::std::mem::offset_of!(yyjson_doc, dat_read) - 40usize];
    ["Offset of field: yyjson_doc::val_read"]
        [::std::mem::offset_of!(yyjson_doc, val_read) - 48usize];
    ["Offset of field: yyjson_doc::str_pool"]
        [::std::mem::offset_of!(yyjson_doc, str_pool) - 56usize];
};
unsafe extern "C" {
    pub fn unsafe_yyjson_equals(lhs: *mut yyjson_val, rhs: *mut yyjson_val) -> bool;
}
#[doc = "Mutable JSON value, 24 bytes.\nThe 'tag' and 'uni' field is same as immutable value.\nThe 'next' field links all elements inside the container to be a cycle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct yyjson_mut_val {
    #[doc = "< type, subtype and length"]
    pub tag: u64,
    #[doc = "< payload"]
    pub uni: yyjson_val_uni,
    #[doc = "< the next value in circular linked list"]
    pub next: *mut yyjson_mut_val,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_mut_val"][::std::mem::size_of::<yyjson_mut_val>() - 24usize];
    ["Alignment of yyjson_mut_val"][::std::mem::align_of::<yyjson_mut_val>() - 8usize];
    ["Offset of field: yyjson_mut_val::tag"][::std::mem::offset_of!(yyjson_mut_val, tag) - 0usize];
    ["Offset of field: yyjson_mut_val::uni"][::std::mem::offset_of!(yyjson_mut_val, uni) - 8usize];
    ["Offset of field: yyjson_mut_val::next"]
        [::std::mem::offset_of!(yyjson_mut_val, next) - 16usize];
};
#[doc = "A memory chunk in string memory pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_str_chunk {
    pub next: *mut yyjson_str_chunk,
    pub chunk_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_str_chunk"][::std::mem::size_of::<yyjson_str_chunk>() - 16usize];
    ["Alignment of yyjson_str_chunk"][::std::mem::align_of::<yyjson_str_chunk>() - 8usize];
    ["Offset of field: yyjson_str_chunk::next"]
        [::std::mem::offset_of!(yyjson_str_chunk, next) - 0usize];
    ["Offset of field: yyjson_str_chunk::chunk_size"]
        [::std::mem::offset_of!(yyjson_str_chunk, chunk_size) - 8usize];
};
#[doc = "A memory pool to hold all strings in a mutable document."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_str_pool {
    pub cur: *mut ::std::os::raw::c_char,
    pub end: *mut ::std::os::raw::c_char,
    pub chunk_size: usize,
    pub chunk_size_max: usize,
    pub chunks: *mut yyjson_str_chunk,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_str_pool"][::std::mem::size_of::<yyjson_str_pool>() - 40usize];
    ["Alignment of yyjson_str_pool"][::std::mem::align_of::<yyjson_str_pool>() - 8usize];
    ["Offset of field: yyjson_str_pool::cur"]
        [::std::mem::offset_of!(yyjson_str_pool, cur) - 0usize];
    ["Offset of field: yyjson_str_pool::end"]
        [::std::mem::offset_of!(yyjson_str_pool, end) - 8usize];
    ["Offset of field: yyjson_str_pool::chunk_size"]
        [::std::mem::offset_of!(yyjson_str_pool, chunk_size) - 16usize];
    ["Offset of field: yyjson_str_pool::chunk_size_max"]
        [::std::mem::offset_of!(yyjson_str_pool, chunk_size_max) - 24usize];
    ["Offset of field: yyjson_str_pool::chunks"]
        [::std::mem::offset_of!(yyjson_str_pool, chunks) - 32usize];
};
#[doc = "A memory chunk in value memory pool.\n`sizeof(yyjson_val_chunk)` should not larger than `sizeof(yyjson_mut_val)`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_val_chunk {
    pub next: *mut yyjson_val_chunk,
    pub chunk_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_val_chunk"][::std::mem::size_of::<yyjson_val_chunk>() - 16usize];
    ["Alignment of yyjson_val_chunk"][::std::mem::align_of::<yyjson_val_chunk>() - 8usize];
    ["Offset of field: yyjson_val_chunk::next"]
        [::std::mem::offset_of!(yyjson_val_chunk, next) - 0usize];
    ["Offset of field: yyjson_val_chunk::chunk_size"]
        [::std::mem::offset_of!(yyjson_val_chunk, chunk_size) - 8usize];
};
#[doc = "A memory pool to hold all values in a mutable document."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_val_pool {
    pub cur: *mut yyjson_mut_val,
    pub end: *mut yyjson_mut_val,
    pub chunk_size: usize,
    pub chunk_size_max: usize,
    pub chunks: *mut yyjson_val_chunk,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_val_pool"][::std::mem::size_of::<yyjson_val_pool>() - 40usize];
    ["Alignment of yyjson_val_pool"][::std::mem::align_of::<yyjson_val_pool>() - 8usize];
    ["Offset of field: yyjson_val_pool::cur"]
        [::std::mem::offset_of!(yyjson_val_pool, cur) - 0usize];
    ["Offset of field: yyjson_val_pool::end"]
        [::std::mem::offset_of!(yyjson_val_pool, end) - 8usize];
    ["Offset of field: yyjson_val_pool::chunk_size"]
        [::std::mem::offset_of!(yyjson_val_pool, chunk_size) - 16usize];
    ["Offset of field: yyjson_val_pool::chunk_size_max"]
        [::std::mem::offset_of!(yyjson_val_pool, chunk_size_max) - 24usize];
    ["Offset of field: yyjson_val_pool::chunks"]
        [::std::mem::offset_of!(yyjson_val_pool, chunks) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yyjson_mut_doc {
    #[doc = "< root value of the JSON document, nullable"]
    pub root: *mut yyjson_mut_val,
    #[doc = "< a valid allocator, nonnull"]
    pub alc: yyjson_alc,
    #[doc = "< string memory pool"]
    pub str_pool: yyjson_str_pool,
    #[doc = "< value memory pool"]
    pub val_pool: yyjson_val_pool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of yyjson_mut_doc"][::std::mem::size_of::<yyjson_mut_doc>() - 120usize];
    ["Alignment of yyjson_mut_doc"][::std::mem::align_of::<yyjson_mut_doc>() - 8usize];
    ["Offset of field: yyjson_mut_doc::root"]
        [::std::mem::offset_of!(yyjson_mut_doc, root) - 0usize];
    ["Offset of field: yyjson_mut_doc::alc"][::std::mem::offset_of!(yyjson_mut_doc, alc) - 8usize];
    ["Offset of field: yyjson_mut_doc::str_pool"]
        [::std::mem::offset_of!(yyjson_mut_doc, str_pool) - 40usize];
    ["Offset of field: yyjson_mut_doc::val_pool"]
        [::std::mem::offset_of!(yyjson_mut_doc, val_pool) - 80usize];
};
unsafe extern "C" {
    pub fn unsafe_yyjson_str_pool_grow(
        pool: *mut yyjson_str_pool,
        alc: *const yyjson_alc,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_val_pool_grow(
        pool: *mut yyjson_val_pool,
        alc: *const yyjson_alc,
        count: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_mut_equals(lhs: *mut yyjson_mut_val, rhs: *mut yyjson_mut_val) -> bool;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_ptr_getx(
        val: *mut yyjson_val,
        ptr: *const ::std::os::raw::c_char,
        len: usize,
        err: *mut yyjson_ptr_err,
    ) -> *mut yyjson_val;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_mut_ptr_getx(
        val: *mut yyjson_mut_val,
        ptr: *const ::std::os::raw::c_char,
        len: usize,
        ctx: *mut yyjson_ptr_ctx,
        err: *mut yyjson_ptr_err,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_mut_ptr_putx(
        val: *mut yyjson_mut_val,
        ptr: *const ::std::os::raw::c_char,
        len: usize,
        new_val: *mut yyjson_mut_val,
        doc: *mut yyjson_mut_doc,
        create_parent: bool,
        insert_new: bool,
        ctx: *mut yyjson_ptr_ctx,
        err: *mut yyjson_ptr_err,
    ) -> bool;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_mut_ptr_replacex(
        val: *mut yyjson_mut_val,
        ptr: *const ::std::os::raw::c_char,
        len: usize,
        new_val: *mut yyjson_mut_val,
        ctx: *mut yyjson_ptr_ctx,
        err: *mut yyjson_ptr_err,
    ) -> *mut yyjson_mut_val;
}
unsafe extern "C" {
    pub fn unsafe_yyjson_mut_ptr_removex(
        val: *mut yyjson_mut_val,
        ptr: *const ::std::os::raw::c_char,
        len: usize,
        ctx: *mut yyjson_ptr_ctx,
        err: *mut yyjson_ptr_err,
    ) -> *mut yyjson_mut_val;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
